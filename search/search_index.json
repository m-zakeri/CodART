{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"CodART: Automated Source Code Refactoring Toolkit Morteza Zakeri \u2020 \u2020 Ph.D. Student, Iran University of Science and Technology, Tehran, Iran (m-zakeri@live.com). Version 0.2.0 (16 March 2021) \u251c Download PDF versions v0.1.0 , v0.2.0 Abstract\u2014 Software refactoring is performed by changing the software structure without modifying its external behavior. Many software quality attributes can be enhanced through the source code refactoring, such as reusability, flexibility, understandability, and testability. Refactoring engines are tools that automate the application of refactorings: first, the user chooses a refactoring to apply, then the engine checks if the transformation is safe, and if so, transforms the program. Refactoring engines are a key component of modern Integrated Development Environments (IDEs), and programmers rely on them to perform refactorings. In this project, an open-source software toolkit for refactoring Java source codes, namely CodART, will be developed. ANTLR parser generator is used to create and modify the program syntax-tree and produce the refactored version of the program. To the best of our knowledge, CodART is the first open-source refactoring toolkit based on ANTLR. Index Terms: Software refactoring, refactoring engine, search-based refactoring, ANTLR, Java. 1 Introduction R efactoring is a behavior-preserving program transformation that improves the design of a program. Refactoring engines are tools that automate the application of refactorings. The programmer need only select which refactoring to apply, and the engine will automatically check the preconditions and apply the transformations across the entire program if the preconditions are satisfied. Refactoring is gaining popularity, as evidenced by the inclusion of refactoring engines in modern IDEs such as IntelliJ IDEA , Eclipse , or NetBeans for Java. Considering the EncapsulateField refactoring as an illustrative example. This refactoring replaces all references to a field with accesses through setter and getter methods. The EncapsulateField refactoring takes as input the name of the field to encapsulate and the names of the new getter and setter methods. It performs the following transformations: Creates a public getter method that returns the field's value, Creates a public setter method that updates the field's value, to a given parameter's value, Replaces all field reads with calls to the getter method, Replaces all field writes with calls to the setter method, Changes the field's access modifier to private. The EncapsulateField refactoring checks several preconditions, including that the code does not already contain accessor methods and that these methods are applicable to the expressions in which the field appears. Figure 1 shows a sample program before and after encapsulating the field f into the getF and setF methods. Figure 1. Example EncapsulateField refactoring Refactoring engines must be reliable. A fault in a refactoring engine can silently introduce bugs in the refactored program and lead to challenging debugging sessions. If the original program compiles, but the refactored program does not, the refactoring is obviously incorrect and can be easily undone. However, if the refactoring engine erroneously produces a refactored program that compiles but does not preserve the semantics of the original program, this can have severe consequences. To perform refactoring correctly, the tool has to operate on the syntax tree of the code, not on the text. Manipulating the syntax tree is much more reliable to preserve what the code is doing. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view, called code transformation. All in all, implementing decent refactoring is a challenging programming exercise, required compiler knowledge. In this project, we develop CodART, a toolkit for applying a given refactoring on the source code and obtain the refactored code. To this aim, we will use ANTLR [1] to generate and modify the program syntax tree. CodART development consists of two phases: In the first phase, 47 common refactoring operations will be automated, and in the second phase, an algorithm to find the best sequence of refactorings to apply on a given software will be developed using many-objective search-based approaches. The rest of this white-paper is organized as follows. Section 2 describes the refactoring operations in detail. Section 3 explains code smells in detail. Section 4 briefly discusses the search-based refactoring techniques and many-objective evolutionary algorithms. Section 5 explains the implementation details of the current version of CodART. Section 6 lists the Java project used to evaluate CodART. Section 7 articulates the proposals that existed behind the CodART projects. Finally, the conclusion and future works are discussed in Section 8. 2 Refactoring operations This section explains the refactoring operations used in the project. A catalog of 72 refactoring operations has been proposed by Fowler [2]. We called this refactorings atomic refactoring operations. Each refactoring operation has a definition and is clearly specified by the entities in which it is involved and the role of each. Table 1 describes the desirable refactorings, which we aim to automate them. It worth noting that not all of these refactoring operations are introduced by Fowler [2]. A concrete example for most of the refactoring operations in the table is available at https://refactoring.com/catalog/ . Examples of other refactorings can be found at https://refactoring.guru/refactoring/techniques and https://sourcemaking.com/refactoring/refactorings . Table 1. Refactoring operations Refactoring Definition Entities Roles Move class Move a class from a package to another package class source package, target package moved class Move method Move a method from a class to another. class method source class, target class moved method Merge packages Merge the elements of a set of packages in one of them package source package, target package Extract/Split package Add a package to compose the elements of another package package source package, target package Extract class Create a new class and move fields and methods from the old class to the new one class method source class, new class moved methods Extract method Extract a code fragment into a method method statement source method, new method moved statements Inline class Move all features of a class in another one and remove it class source class, target class Move field Move a field from a class to another class field source class, target class field Push down field Move a field of a superclass to a subclass class field super class, sub classes move field Push down method Move a method of a superclass to a subclass class method super class, sub classes moved method Pull up field Move a field from subclasses to the superclass class field sub classes, super class moved field Pull up method Move a method from subclasses to the superclass class method sub classes, super class moved method Increase field visibility Increase the visibility of a field from public to protected, protected to package or package to private class field source class source filed Decrease field visibility Decrease the visibility of a field from private to package, package to protected or protected to public class field source class source filed Make field final Make a non-final field final class field source class source filed Make field non-final Make a final field non-final class field source class source filed Make field static Make a non-static field static class field source class source filed Make field non-static Make a static field non-static class field source class source filed Remove field Remove a field from a class class field source class source filed Increase method visibility Increase the visibility of a method from public to protected, protected to package or package to private class method source class source method Decrease method visibility Decrease the visibility of a method from private to package, package to protected or protected to public class method source class source method Make method final Make a non-final method final class method source class source method Make method non-final Make a final method non-final class method source class source method Make method static Make a non-static method static class method source class source method Make method non-static Make a static method non-static class method source class source method Remove method Remove a method from a class class method source class source method Make class-final Make a non-final class final class source class Make class non-final Make a final class non-final class source class Make class abstract Change a concrete class to abstract class source class Make class concrete Change an abstract class to concrete class source class Extract subclass Create a subclass for a set of features class method source class, new subclass moved methods Extract interface Extract methods of a class into an interface class method source class, new interface interface methods Inline method Move the body of a method into its callers and remove the method method source method, callers method Collapse hierarchy Merge a superclass and a subclass class superclass, subclass Remove control flag Replace control flag with a break class method source class source method Replace nested conditional with guard clauses Replace nested conditional with guard clauses class method source class source method Replace constructor with a factory function Replace constructor with a factory function class source class Replace exception with test Replace exception with precheck class method source class source method Rename field Rename a field class field source class source filed Rename method Rename a method class method source class source method Rename class Rename a class class source class Rename package Rename a package package source package Encapsulate field Create setter/mutator and getter/accessor methods for a private field class field source class source filed Replace parameter with query Replace parameter with query class method source class source method Pull up constructor body Move the constructor class method subclass class, superclass constructor Replace control flag with break Replace control flag with break class method source class source method Remove flag argument Remove flag argument class method source class source method Total 47 \u2014 \u2014 3 Code smells Deciding when and where to start refactoring\u2014and when and where to stop\u2014is just as important to refactoring as knowing how to operate its mechanics [2]. To answer this important question, we should know the refactoring activities. The refactoring process consists of six distinct activities [9]: Identify where the software should be refactored. Determine which refactoring(s) should be applied to the identified places. Guarantee that the applied refactoring preserves behavior. Apply the refactoring. Assess the effect of the refactoring on quality characteristics of the software (e.g., complexity, understandability, maintainability) or the process (e.g., productivity, cost, effort). Maintain the consistency between the refactored program code and other software artifacts (such as documentation, design documents, requirements specifications, tests, etc.). Table 2. Code smells Code smell Descriptions and other names God class The class defines many data members (fields) and methods and exhibits low cohesion. The god class smell occurs when a huge class surrounded by many data classes acts as a controller (i.e., takes most of the decisions and monopolizes the software's functionality). Other names: Blob, large class, brain class. Long method This smell occurs when a method is too long to understand and most presumably perform more than one responsibility. Other names: God method, brain method, large method. Feature envy This smell occurs when a method seems more interested in a class other than the one it actually is in. Data class This smell occurs when a class contains only fields and possibly getters/setters without any behavior (methods). Shotgun surgery This smell characterizes the situation when one kind of change leads to many changes to multiple different classes. When the changes are all over the place, they are hard to find, and it is easy to miss a necessary change. Refused bequest This smell occurs when a subclass rejects some of the methods or properties offered by its superclass. Functional decomposition This smell occurs when the experienced developers coming from procedural languages background write highly procedural and non-object-oriented code in an object-oriented language. Long parameter list This smell occurs when a method accepts a long list of parameters. Such lists are hard to understand and difficult to use. Promiscuous package A package can be considered promiscuous if it contains classes implementing too many features, making it too hard to understand and maintain. As for god class and long method, this smell arises when the package has low cohesion since it manages different responsibilities. Misplaced class A Misplaced Class smell suggests a class that is in a package that contains other classes not related to it. Switch statement This smell occurs when switch statements that switch on type codes are spread across the software system instead of exploiting polymorphism. Spaghetti code This smell refers to an unmaintainable, incomprehensible code without any structure. The smell does not exploit and prevents the use of object-orientation mechanisms and concepts. Divergent change Divergent change occurs when one class is commonly changed in different ways for different reasons. Other names: Multifaceted abstraction Deficient encapsulation This smell occurs when the declared accessibility of one or more members of abstraction is more permissive than actually required. Swiss army knife This smell arises when the designer attempts to provide all possible uses of the class and ends up in an excessively complex class interface. Lazy class Unnecessary abstraction Cyclically-dependent modularization This smell arises when two or more abstractions depend on each other directly or indirectly. Primitive obsession This smell occurs when primitive data types are used where an abstraction encapsulating the primitives could serve better. Speculative generality This smell occurs where abstraction is created based on speculated requirements. It is often unnecessary that makes things difficult to understand and maintain. Message chains A message chain occurs when a client requests another object, that object requests yet another one, and so on. These chains mean that the client is dependent on navigation along with the class structure. Any changes in these relationships require modifying the client. Total 20 4 Search-based refactoring After refactoring operations were automated, we must decide which refactorings souled be performed in order to elevate software quality. The concern about using refactoring operations in Table 1 is whether each one of them has a positive impact on the refactored code quality or not. Finding the right sequence of refactorings to be applied in a software artifact is considered a challenging task since there is a wide range of refactorings. The ideal sequence is, therefore, must correlate to different quality attributes to be improved as a result of applying refactorings. Finding the best refactoring sequence is an optimization problem that can be solved by search techniques in the field known as Search-Based Software Engineering (SBSE) [3]. In this approach, refactorings are applied stochastically to the original software solution, and then the software is measured using a fitness function consisting of one or more software metrics. There are various metric suites available to measure characteristics like cohesion and coupling, but different metrics measure the software in different ways, and thus how they are applied will have a different effect on the outcome. The second phase of this project is to use a many-objective search algorithm to find the best sequence of refactoring on a given project. Recently, many-objective SBSE approach for refactoring [3]\u2013[5] and remodularization, regrouping a set of classes C in terms of packages P, [6] has gained more attention due to its ability to find the best sequence of refactoring operations which is led to the improvement in software quality. Therefore, we first focus on implementing the proposed approach approaches in [3], [5], [6] as fundamental works in this area. Then, we will improve their approach. As a new contribution, we add new refactoring operations and new objective functions to improve the quality attribute of the software. We also evaluate our method on the new software projects which are not used in previous works. 5 Implementation This section describes implementation details of the CodART. It includes CodART architecture, high-level repository directories structure, refactoring automation with ANTLR parser generator, and refactoring recommendation through many-objective search-based software engineering techniques. 5.1 CodART architecture The high-level architecture of CodART is shown in Figure 2. The source code consists of several Python packages and directories. We briefly describe each component in CodART. Figure 2. CodART architecture I. grammars : This directory contains three ANTLR4 grammars for the Java programming language: Java9_v2.g4 : This grammar was used in the initial version of CodART. The main problem of this grammar is that parsing large source code files is performed very slow due to some decisions used in grammar design. We have switched to the fast grammar JavaParserLabled.g4 . JavaLexer.g4 : The lexer of Java fast grammar. This lexer is used for both fast parsers, i.e., JavaParser.g4 and JavaParserLabeled. JavaParser.g4 : The original parser of Java fast grammar. This parser is currently used in some refactoring. In the future release, this grammar will be replaced with JavaPaseredLabled.g4 . JavaParserLabeled.g4 : This file contains the same JavaParsar.g4 grammar. The only difference is that the rules with more than one extension are labled with a specific name. The ANTLR parser generator thus generates separate visitor and listener methods for each extension. This grammar facilitates the development of some refactoring. It is the preferred parser in CodART project. II. gen : The gen packages contain all generated source code for the parser, lexer, visitor, and listener for different grammars available in the grammars directory. To develop refactorings and code smells, gen.JavaLabled package, which contains JavaParserLabled.g4 generated source code, must be used. The content of this package is generated automatically , and therefore it should not be modified manually . Modules within this gen package are just for importing and using in other modules. III. speedy : The python implementation for ANTLR is less efficient than Java or C++ implementation. The speedy module implements a Java parser with a C++ back-end, improving the efficiency and speed of parsing. It uses speedy-antlr implementation with some minor changes. The current version of the speedy module use java9_v2.g4 grammar, which inherently slow as described. To switch to C++ back-end, first, the speedy module must be installed on the client system. It requires a C++ compiler. We recommended to CodART developers using the Python back-end as switching to C++ back-end would be done transparently in the future release. The Python back-end saves debugging and developing time. IV. refactorings : The refactorings package is the main package in the CodART project and contains numerous Python modules that form the kernel functionalities of CodART. Each module implements the automation of one refactoring operation according to standard practices. The modules may include several classes which inherit from ANTLR listeners. Sub-packages in this module contain refactorings, which are in an early step of development or deprecated version of an existing refactoring. This package is under active development and testing. The module in the root packages can be used for testing purposes. V. refactoring_design_patters : The refactoring_design_pattern packages contain modules that implement refactoring to a specific design pattern automatically. VI. smells : The smell package implements the automatic detection of software code and design smells relevant to the refactoring operation supported by CodART. Each smell corresponds to one or more refactoring in the refactoring package. VII. metrics : The metrics packages contain several modules that implement the computation of the most well-known source code metrics. These metrics used to detect code smells and measuring the quality of software in terms of quality attributed. VIII. tests : The test directory contains individual test data and test cases that are used for developing specific refactorings. Typically, each test case is a single Java file that contains one or more Java classes. IX. benchmark_projects : This directory contains several open-source Java projects formerly used in automated refactoring researches by many researchers. Once the implementation of refactoring is completed, it will be executed and tested on all projects in this benchmark to ensure the generalization of functionality proposed by the implementation. X. Other packages : The information of other packages will be announced in the future. 5.2 Refactoring automation Each refactoring operation in Table 1 is implemented as an API, with the refactoring name. The API receives the involved entities with their refactoring roles and other required data as inputs, checks the feasibility of the refactoring using refactoring preconditions described in [2], performs the refactoring if it is feasible, and returns the refactored code or return null if the refactoring is not feasible. The core of our refactoring engine is a syntax-tree modification algorithm. Fundamentally, ANTLR is used to generate and modify the syntax-tree of a given program. Each refactoring API is an ANTLR Listener or visitor class, which required argument by its constructor and preform refactoring when call by parse-tree walker object. The refactoring target and input parameters must read from a configuration file, which can be expressed in JSON, XML, or YAML formats. The key to use ANTLR for refactoring tasks is the TokenStreamRewriter object that knows how to give altered views of a token stream without actually modifying the stream. It treats all of the manipulation methods as \"instructions\" and queues them up for lazy execution when traversing the token stream to render it back as text. The rewriter executes those instructions every time we call getText() . This strategy is very effective for the general problem of source code instrumentation or refactoring. The TokenStreamRewriter is a powerful and extremely efficient means of manipulating a token stream. 5.3 Refactoring recommendation A solution consists of a sequence of n refactoring operations applied to different code elements in the source code to fix. In order to represent a candidate solution (individual/chromosome), we use a vector-based representation. Each vector\u2019s dimension represents a refactoring operation where the order of applying these refactoring operations corresponds to their positions in the vector. The initial population is generated by randomly assigning a sequence of refactorings to some code fragments. Each generated refactoring solution is executed on the software system S . Once all required data is computed, the solution is evaluated based on the quality of the resulting design. 6 Benchmark projects and testbed To ensure CodART works properly, we are running it on many real-life software projects. Refactorings are applied to the software systems listed in Table 3. Benchmark projects may update and extend in the future. For the time being, we use a set of well-known open-source Java projects that have been intensely studied in previous works. We have also added two new Java software programs, WEKA and ANTLR, to examine the versatility of CodART performance on real-life software projects. Table 3. Software systems refactored in this project System Release Previous releases Domain Reference Xerces-J v2.7.0 -- software packages for parsing XML [3], [6] Azureus v2.3.0.6 -- Java BitTorrent client for handling multiple torrents [3] ArgoUML v0.26 and v0.3 -- UML tool for object-oriented design [3] Apache Ant v1.5.0 and v1.7.0 -- Java build tool and library [3] GanttProject v1.10.2 and v1.11.1 -- project management [3], [6], [5] JHotDraw v6.1 and v6.0b1 and v5.3 -- graphics tool [6], [5], [4] JFreeChart v1.0.9 -- chart tool [6] Beaver v0.9.11 and v0.9.8 -- parser generator [5], [4] Apache XML-RPC v3.1.1 -- B2B communications [5], [4] JRDF v0.3.4.3 -- semantic web (resource management) [5] XOM v1.2.1 -- XML tool [5] JSON v1.1 -- software packages for parsing JSON [4] JFlex v1.4.1 -- lexical analyzer generator [4] Mango v2.0.1 -- -- [4] Weka v3.9 -- data mining tool New ANTLR v4.8.0 -- parser generator tool New 7 CodART in IUST Developing a comprehensive refactoring engine required thousand of hours of programming. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view. According to a quote by Fowler [2] in his well-known refactoring book: \u201cimplementing decent refactoring is a challenging programming exercise\u2014one that I\u2019m mostly unaware of as I gaily use the tools.\u201d We have defined the basic functionalities of the CodART system as several student projects with different proposals. Students who will take our computer science course, including compiler design and construction, advanced compilers, and advanced software engineering, must be worked on these proposals as part of their course fulfillments. These projects try to familiarize students with the practical usage of compilers from the software engineering point of view. The detailed information of our current proposals are available in the following links: Core refactoring operations development (Fall 2020) Core code smells development Current semester (Winter and Spring 2021) Core search-based development (Future semesters) Core refactoring to design patterns development (Future semesters) Note: Students whose final project is confirmed by the reverse engineering laboratory have an opportunity to work on CodART as an independent and advanced research project. The only prerequisite is to pass the compiler graduate course by Dr. Saeed Parsa. 8 Conclusion and remarks Software refactoring is used to reduce the costs and risks of software evolution. Automated software refactoring tools can reduce risks caused by manual refactoring, improve efficiency, and reduce software refactoring difficulties. Researchers have made great efforts to research how to implement and improve automated software refactoring tools. However, the results of automated refactoring tools often deviate from the intentions of the implementer. The goal of this project is to propose an open-source refactoring engine and toolkit that can automatically find the best refactoring sequence required for a given software and apply this sequence. Since the tool is work based on compiler principles, it is reliable to be used in practice and has many benefits for software developer companies. Students who participate in the project will learn compiler techniques such as lexing, parsing, source code analysis, and source code transformation. They also learn about software refactoring, search-based software engineering, optimization, software quality, and object-orient metrics. Conflict of interest The project is supported by the IUST Reverse Engineering Research Laboratory . Interested students may continue working on this project to fulfill their final bachelor and master thesis or their internship. References [1] T. Parr and K. Fisher, \u201cLL(*): the foundation of the ANTLR parser generator,\u201d Proc. 32nd ACM SIGPLAN Conf. Program. Lang. Des. Implement., pp. 425\u2013436, 2011. [2] M. K. B. Fowler, Refactoring: improving the design of existing code, Second Edi. Addison-Wesley, 2018. [3] M. W. Mkaouer, M. Kessentini, S. Bechikh, M. O\u0301 Cinne\u0301ide, and K. Deb, \u201cOn the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,\u201d Empir. Softw. Eng., vol. 21, no. 6, pp. 2503\u20132545, Dec. 2016. [4] M. Mohan, D. Greer, and P. McMullan, \u201cTechnical debt reduction using search based automated refactoring,\u201d J. Syst. Softw., vol. 120, pp. 183\u2013194, Oct. 2016. [5] M. Mohan and D. Greer, \u201cUsing a many-objective approach to investigate automated refactoring,\u201d Inf. Softw. Technol., vol. 112, pp. 83\u2013101, Aug. 2019. [6] W. Mkaouer et al., \u201cMany-Objective Software Remodularization Using NSGA-III,\u201d ACM Trans. Softw. Eng. Methodol., vol. 24, no. 3, pp. 1\u201345, May 2015. [7] M. Mohan and D. Greer, \u201cMultiRefactor: automated refactoring to improve software quality,\u201d 2017, pp. 556\u2013572. [8] N. Tsantalis, T. Chaikalis, and A. Chatzigeorgiou, \u201cTen years of JDeodorant: lessons learned from the hunt for smells,\u201d in 2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER), 2018, pp. 4\u201314. [9] T. Mens and T. Tourwe, \u201cA survey of software refactoring,\u201d IEEE Trans. Softw. Eng., vol. 30, no. 2, pp. 126\u2013139, Feb. 2004. Related links IUST compiler course official webpage ANTLR slides: PART 1: Introduction ANTLR slides: PART 2: Getting started in Java ANTLR slides: PART 3: Getting started in C# Endnotes [1] https://www.jetbrains.com/idea/ [2] http://www.eclipse.org [3] http://www.netbeans.org [4] https://github.com/mmohan01/MultiRefactor [5] http://sourceforge.net/projects/recoder [6] http://reverse.iust.ac.ir","title":"Home"},{"location":"#codart-automated-source-code-refactoring-toolkit","text":"Morteza Zakeri \u2020 \u2020 Ph.D. Student, Iran University of Science and Technology, Tehran, Iran (m-zakeri@live.com). Version 0.2.0 (16 March 2021) \u251c Download PDF versions v0.1.0 , v0.2.0 Abstract\u2014 Software refactoring is performed by changing the software structure without modifying its external behavior. Many software quality attributes can be enhanced through the source code refactoring, such as reusability, flexibility, understandability, and testability. Refactoring engines are tools that automate the application of refactorings: first, the user chooses a refactoring to apply, then the engine checks if the transformation is safe, and if so, transforms the program. Refactoring engines are a key component of modern Integrated Development Environments (IDEs), and programmers rely on them to perform refactorings. In this project, an open-source software toolkit for refactoring Java source codes, namely CodART, will be developed. ANTLR parser generator is used to create and modify the program syntax-tree and produce the refactored version of the program. To the best of our knowledge, CodART is the first open-source refactoring toolkit based on ANTLR. Index Terms: Software refactoring, refactoring engine, search-based refactoring, ANTLR, Java.","title":"CodART: Automated Source Code Refactoring Toolkit"},{"location":"#1-introduction","text":"R efactoring is a behavior-preserving program transformation that improves the design of a program. Refactoring engines are tools that automate the application of refactorings. The programmer need only select which refactoring to apply, and the engine will automatically check the preconditions and apply the transformations across the entire program if the preconditions are satisfied. Refactoring is gaining popularity, as evidenced by the inclusion of refactoring engines in modern IDEs such as IntelliJ IDEA , Eclipse , or NetBeans for Java. Considering the EncapsulateField refactoring as an illustrative example. This refactoring replaces all references to a field with accesses through setter and getter methods. The EncapsulateField refactoring takes as input the name of the field to encapsulate and the names of the new getter and setter methods. It performs the following transformations: Creates a public getter method that returns the field's value, Creates a public setter method that updates the field's value, to a given parameter's value, Replaces all field reads with calls to the getter method, Replaces all field writes with calls to the setter method, Changes the field's access modifier to private. The EncapsulateField refactoring checks several preconditions, including that the code does not already contain accessor methods and that these methods are applicable to the expressions in which the field appears. Figure 1 shows a sample program before and after encapsulating the field f into the getF and setF methods. Figure 1. Example EncapsulateField refactoring Refactoring engines must be reliable. A fault in a refactoring engine can silently introduce bugs in the refactored program and lead to challenging debugging sessions. If the original program compiles, but the refactored program does not, the refactoring is obviously incorrect and can be easily undone. However, if the refactoring engine erroneously produces a refactored program that compiles but does not preserve the semantics of the original program, this can have severe consequences. To perform refactoring correctly, the tool has to operate on the syntax tree of the code, not on the text. Manipulating the syntax tree is much more reliable to preserve what the code is doing. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view, called code transformation. All in all, implementing decent refactoring is a challenging programming exercise, required compiler knowledge. In this project, we develop CodART, a toolkit for applying a given refactoring on the source code and obtain the refactored code. To this aim, we will use ANTLR [1] to generate and modify the program syntax tree. CodART development consists of two phases: In the first phase, 47 common refactoring operations will be automated, and in the second phase, an algorithm to find the best sequence of refactorings to apply on a given software will be developed using many-objective search-based approaches. The rest of this white-paper is organized as follows. Section 2 describes the refactoring operations in detail. Section 3 explains code smells in detail. Section 4 briefly discusses the search-based refactoring techniques and many-objective evolutionary algorithms. Section 5 explains the implementation details of the current version of CodART. Section 6 lists the Java project used to evaluate CodART. Section 7 articulates the proposals that existed behind the CodART projects. Finally, the conclusion and future works are discussed in Section 8.","title":"1 Introduction"},{"location":"#2-refactoring-operations","text":"This section explains the refactoring operations used in the project. A catalog of 72 refactoring operations has been proposed by Fowler [2]. We called this refactorings atomic refactoring operations. Each refactoring operation has a definition and is clearly specified by the entities in which it is involved and the role of each. Table 1 describes the desirable refactorings, which we aim to automate them. It worth noting that not all of these refactoring operations are introduced by Fowler [2]. A concrete example for most of the refactoring operations in the table is available at https://refactoring.com/catalog/ . Examples of other refactorings can be found at https://refactoring.guru/refactoring/techniques and https://sourcemaking.com/refactoring/refactorings . Table 1. Refactoring operations Refactoring Definition Entities Roles Move class Move a class from a package to another package class source package, target package moved class Move method Move a method from a class to another. class method source class, target class moved method Merge packages Merge the elements of a set of packages in one of them package source package, target package Extract/Split package Add a package to compose the elements of another package package source package, target package Extract class Create a new class and move fields and methods from the old class to the new one class method source class, new class moved methods Extract method Extract a code fragment into a method method statement source method, new method moved statements Inline class Move all features of a class in another one and remove it class source class, target class Move field Move a field from a class to another class field source class, target class field Push down field Move a field of a superclass to a subclass class field super class, sub classes move field Push down method Move a method of a superclass to a subclass class method super class, sub classes moved method Pull up field Move a field from subclasses to the superclass class field sub classes, super class moved field Pull up method Move a method from subclasses to the superclass class method sub classes, super class moved method Increase field visibility Increase the visibility of a field from public to protected, protected to package or package to private class field source class source filed Decrease field visibility Decrease the visibility of a field from private to package, package to protected or protected to public class field source class source filed Make field final Make a non-final field final class field source class source filed Make field non-final Make a final field non-final class field source class source filed Make field static Make a non-static field static class field source class source filed Make field non-static Make a static field non-static class field source class source filed Remove field Remove a field from a class class field source class source filed Increase method visibility Increase the visibility of a method from public to protected, protected to package or package to private class method source class source method Decrease method visibility Decrease the visibility of a method from private to package, package to protected or protected to public class method source class source method Make method final Make a non-final method final class method source class source method Make method non-final Make a final method non-final class method source class source method Make method static Make a non-static method static class method source class source method Make method non-static Make a static method non-static class method source class source method Remove method Remove a method from a class class method source class source method Make class-final Make a non-final class final class source class Make class non-final Make a final class non-final class source class Make class abstract Change a concrete class to abstract class source class Make class concrete Change an abstract class to concrete class source class Extract subclass Create a subclass for a set of features class method source class, new subclass moved methods Extract interface Extract methods of a class into an interface class method source class, new interface interface methods Inline method Move the body of a method into its callers and remove the method method source method, callers method Collapse hierarchy Merge a superclass and a subclass class superclass, subclass Remove control flag Replace control flag with a break class method source class source method Replace nested conditional with guard clauses Replace nested conditional with guard clauses class method source class source method Replace constructor with a factory function Replace constructor with a factory function class source class Replace exception with test Replace exception with precheck class method source class source method Rename field Rename a field class field source class source filed Rename method Rename a method class method source class source method Rename class Rename a class class source class Rename package Rename a package package source package Encapsulate field Create setter/mutator and getter/accessor methods for a private field class field source class source filed Replace parameter with query Replace parameter with query class method source class source method Pull up constructor body Move the constructor class method subclass class, superclass constructor Replace control flag with break Replace control flag with break class method source class source method Remove flag argument Remove flag argument class method source class source method Total 47 \u2014 \u2014","title":"2 Refactoring operations"},{"location":"#3-code-smells","text":"Deciding when and where to start refactoring\u2014and when and where to stop\u2014is just as important to refactoring as knowing how to operate its mechanics [2]. To answer this important question, we should know the refactoring activities. The refactoring process consists of six distinct activities [9]: Identify where the software should be refactored. Determine which refactoring(s) should be applied to the identified places. Guarantee that the applied refactoring preserves behavior. Apply the refactoring. Assess the effect of the refactoring on quality characteristics of the software (e.g., complexity, understandability, maintainability) or the process (e.g., productivity, cost, effort). Maintain the consistency between the refactored program code and other software artifacts (such as documentation, design documents, requirements specifications, tests, etc.). Table 2. Code smells Code smell Descriptions and other names God class The class defines many data members (fields) and methods and exhibits low cohesion. The god class smell occurs when a huge class surrounded by many data classes acts as a controller (i.e., takes most of the decisions and monopolizes the software's functionality). Other names: Blob, large class, brain class. Long method This smell occurs when a method is too long to understand and most presumably perform more than one responsibility. Other names: God method, brain method, large method. Feature envy This smell occurs when a method seems more interested in a class other than the one it actually is in. Data class This smell occurs when a class contains only fields and possibly getters/setters without any behavior (methods). Shotgun surgery This smell characterizes the situation when one kind of change leads to many changes to multiple different classes. When the changes are all over the place, they are hard to find, and it is easy to miss a necessary change. Refused bequest This smell occurs when a subclass rejects some of the methods or properties offered by its superclass. Functional decomposition This smell occurs when the experienced developers coming from procedural languages background write highly procedural and non-object-oriented code in an object-oriented language. Long parameter list This smell occurs when a method accepts a long list of parameters. Such lists are hard to understand and difficult to use. Promiscuous package A package can be considered promiscuous if it contains classes implementing too many features, making it too hard to understand and maintain. As for god class and long method, this smell arises when the package has low cohesion since it manages different responsibilities. Misplaced class A Misplaced Class smell suggests a class that is in a package that contains other classes not related to it. Switch statement This smell occurs when switch statements that switch on type codes are spread across the software system instead of exploiting polymorphism. Spaghetti code This smell refers to an unmaintainable, incomprehensible code without any structure. The smell does not exploit and prevents the use of object-orientation mechanisms and concepts. Divergent change Divergent change occurs when one class is commonly changed in different ways for different reasons. Other names: Multifaceted abstraction Deficient encapsulation This smell occurs when the declared accessibility of one or more members of abstraction is more permissive than actually required. Swiss army knife This smell arises when the designer attempts to provide all possible uses of the class and ends up in an excessively complex class interface. Lazy class Unnecessary abstraction Cyclically-dependent modularization This smell arises when two or more abstractions depend on each other directly or indirectly. Primitive obsession This smell occurs when primitive data types are used where an abstraction encapsulating the primitives could serve better. Speculative generality This smell occurs where abstraction is created based on speculated requirements. It is often unnecessary that makes things difficult to understand and maintain. Message chains A message chain occurs when a client requests another object, that object requests yet another one, and so on. These chains mean that the client is dependent on navigation along with the class structure. Any changes in these relationships require modifying the client. Total 20","title":"3 Code smells"},{"location":"#4-search-based-refactoring","text":"After refactoring operations were automated, we must decide which refactorings souled be performed in order to elevate software quality. The concern about using refactoring operations in Table 1 is whether each one of them has a positive impact on the refactored code quality or not. Finding the right sequence of refactorings to be applied in a software artifact is considered a challenging task since there is a wide range of refactorings. The ideal sequence is, therefore, must correlate to different quality attributes to be improved as a result of applying refactorings. Finding the best refactoring sequence is an optimization problem that can be solved by search techniques in the field known as Search-Based Software Engineering (SBSE) [3]. In this approach, refactorings are applied stochastically to the original software solution, and then the software is measured using a fitness function consisting of one or more software metrics. There are various metric suites available to measure characteristics like cohesion and coupling, but different metrics measure the software in different ways, and thus how they are applied will have a different effect on the outcome. The second phase of this project is to use a many-objective search algorithm to find the best sequence of refactoring on a given project. Recently, many-objective SBSE approach for refactoring [3]\u2013[5] and remodularization, regrouping a set of classes C in terms of packages P, [6] has gained more attention due to its ability to find the best sequence of refactoring operations which is led to the improvement in software quality. Therefore, we first focus on implementing the proposed approach approaches in [3], [5], [6] as fundamental works in this area. Then, we will improve their approach. As a new contribution, we add new refactoring operations and new objective functions to improve the quality attribute of the software. We also evaluate our method on the new software projects which are not used in previous works.","title":"4 Search-based refactoring"},{"location":"#5-implementation","text":"This section describes implementation details of the CodART. It includes CodART architecture, high-level repository directories structure, refactoring automation with ANTLR parser generator, and refactoring recommendation through many-objective search-based software engineering techniques.","title":"5 Implementation"},{"location":"#51-codart-architecture","text":"The high-level architecture of CodART is shown in Figure 2. The source code consists of several Python packages and directories. We briefly describe each component in CodART. Figure 2. CodART architecture I. grammars : This directory contains three ANTLR4 grammars for the Java programming language: Java9_v2.g4 : This grammar was used in the initial version of CodART. The main problem of this grammar is that parsing large source code files is performed very slow due to some decisions used in grammar design. We have switched to the fast grammar JavaParserLabled.g4 . JavaLexer.g4 : The lexer of Java fast grammar. This lexer is used for both fast parsers, i.e., JavaParser.g4 and JavaParserLabeled. JavaParser.g4 : The original parser of Java fast grammar. This parser is currently used in some refactoring. In the future release, this grammar will be replaced with JavaPaseredLabled.g4 . JavaParserLabeled.g4 : This file contains the same JavaParsar.g4 grammar. The only difference is that the rules with more than one extension are labled with a specific name. The ANTLR parser generator thus generates separate visitor and listener methods for each extension. This grammar facilitates the development of some refactoring. It is the preferred parser in CodART project. II. gen : The gen packages contain all generated source code for the parser, lexer, visitor, and listener for different grammars available in the grammars directory. To develop refactorings and code smells, gen.JavaLabled package, which contains JavaParserLabled.g4 generated source code, must be used. The content of this package is generated automatically , and therefore it should not be modified manually . Modules within this gen package are just for importing and using in other modules. III. speedy : The python implementation for ANTLR is less efficient than Java or C++ implementation. The speedy module implements a Java parser with a C++ back-end, improving the efficiency and speed of parsing. It uses speedy-antlr implementation with some minor changes. The current version of the speedy module use java9_v2.g4 grammar, which inherently slow as described. To switch to C++ back-end, first, the speedy module must be installed on the client system. It requires a C++ compiler. We recommended to CodART developers using the Python back-end as switching to C++ back-end would be done transparently in the future release. The Python back-end saves debugging and developing time. IV. refactorings : The refactorings package is the main package in the CodART project and contains numerous Python modules that form the kernel functionalities of CodART. Each module implements the automation of one refactoring operation according to standard practices. The modules may include several classes which inherit from ANTLR listeners. Sub-packages in this module contain refactorings, which are in an early step of development or deprecated version of an existing refactoring. This package is under active development and testing. The module in the root packages can be used for testing purposes. V. refactoring_design_patters : The refactoring_design_pattern packages contain modules that implement refactoring to a specific design pattern automatically. VI. smells : The smell package implements the automatic detection of software code and design smells relevant to the refactoring operation supported by CodART. Each smell corresponds to one or more refactoring in the refactoring package. VII. metrics : The metrics packages contain several modules that implement the computation of the most well-known source code metrics. These metrics used to detect code smells and measuring the quality of software in terms of quality attributed. VIII. tests : The test directory contains individual test data and test cases that are used for developing specific refactorings. Typically, each test case is a single Java file that contains one or more Java classes. IX. benchmark_projects : This directory contains several open-source Java projects formerly used in automated refactoring researches by many researchers. Once the implementation of refactoring is completed, it will be executed and tested on all projects in this benchmark to ensure the generalization of functionality proposed by the implementation. X. Other packages : The information of other packages will be announced in the future.","title":"5.1 CodART architecture"},{"location":"#52-refactoring-automation","text":"Each refactoring operation in Table 1 is implemented as an API, with the refactoring name. The API receives the involved entities with their refactoring roles and other required data as inputs, checks the feasibility of the refactoring using refactoring preconditions described in [2], performs the refactoring if it is feasible, and returns the refactored code or return null if the refactoring is not feasible. The core of our refactoring engine is a syntax-tree modification algorithm. Fundamentally, ANTLR is used to generate and modify the syntax-tree of a given program. Each refactoring API is an ANTLR Listener or visitor class, which required argument by its constructor and preform refactoring when call by parse-tree walker object. The refactoring target and input parameters must read from a configuration file, which can be expressed in JSON, XML, or YAML formats. The key to use ANTLR for refactoring tasks is the TokenStreamRewriter object that knows how to give altered views of a token stream without actually modifying the stream. It treats all of the manipulation methods as \"instructions\" and queues them up for lazy execution when traversing the token stream to render it back as text. The rewriter executes those instructions every time we call getText() . This strategy is very effective for the general problem of source code instrumentation or refactoring. The TokenStreamRewriter is a powerful and extremely efficient means of manipulating a token stream.","title":"5.2 Refactoring automation"},{"location":"#53-refactoring-recommendation","text":"A solution consists of a sequence of n refactoring operations applied to different code elements in the source code to fix. In order to represent a candidate solution (individual/chromosome), we use a vector-based representation. Each vector\u2019s dimension represents a refactoring operation where the order of applying these refactoring operations corresponds to their positions in the vector. The initial population is generated by randomly assigning a sequence of refactorings to some code fragments. Each generated refactoring solution is executed on the software system S . Once all required data is computed, the solution is evaluated based on the quality of the resulting design.","title":"5.3 Refactoring recommendation"},{"location":"#6-benchmark-projects-and-testbed","text":"To ensure CodART works properly, we are running it on many real-life software projects. Refactorings are applied to the software systems listed in Table 3. Benchmark projects may update and extend in the future. For the time being, we use a set of well-known open-source Java projects that have been intensely studied in previous works. We have also added two new Java software programs, WEKA and ANTLR, to examine the versatility of CodART performance on real-life software projects. Table 3. Software systems refactored in this project System Release Previous releases Domain Reference Xerces-J v2.7.0 -- software packages for parsing XML [3], [6] Azureus v2.3.0.6 -- Java BitTorrent client for handling multiple torrents [3] ArgoUML v0.26 and v0.3 -- UML tool for object-oriented design [3] Apache Ant v1.5.0 and v1.7.0 -- Java build tool and library [3] GanttProject v1.10.2 and v1.11.1 -- project management [3], [6], [5] JHotDraw v6.1 and v6.0b1 and v5.3 -- graphics tool [6], [5], [4] JFreeChart v1.0.9 -- chart tool [6] Beaver v0.9.11 and v0.9.8 -- parser generator [5], [4] Apache XML-RPC v3.1.1 -- B2B communications [5], [4] JRDF v0.3.4.3 -- semantic web (resource management) [5] XOM v1.2.1 -- XML tool [5] JSON v1.1 -- software packages for parsing JSON [4] JFlex v1.4.1 -- lexical analyzer generator [4] Mango v2.0.1 -- -- [4] Weka v3.9 -- data mining tool New ANTLR v4.8.0 -- parser generator tool New","title":"6 Benchmark projects and testbed"},{"location":"#7-codart-in-iust","text":"Developing a comprehensive refactoring engine required thousand of hours of programming. Refactoring is not just understanding and updating the syntax tree. The tool also needs to figure out how to rerender the code into text back in the editor view. According to a quote by Fowler [2] in his well-known refactoring book: \u201cimplementing decent refactoring is a challenging programming exercise\u2014one that I\u2019m mostly unaware of as I gaily use the tools.\u201d We have defined the basic functionalities of the CodART system as several student projects with different proposals. Students who will take our computer science course, including compiler design and construction, advanced compilers, and advanced software engineering, must be worked on these proposals as part of their course fulfillments. These projects try to familiarize students with the practical usage of compilers from the software engineering point of view. The detailed information of our current proposals are available in the following links: Core refactoring operations development (Fall 2020) Core code smells development Current semester (Winter and Spring 2021) Core search-based development (Future semesters) Core refactoring to design patterns development (Future semesters) Note: Students whose final project is confirmed by the reverse engineering laboratory have an opportunity to work on CodART as an independent and advanced research project. The only prerequisite is to pass the compiler graduate course by Dr. Saeed Parsa.","title":"7 CodART in IUST"},{"location":"#8-conclusion-and-remarks","text":"Software refactoring is used to reduce the costs and risks of software evolution. Automated software refactoring tools can reduce risks caused by manual refactoring, improve efficiency, and reduce software refactoring difficulties. Researchers have made great efforts to research how to implement and improve automated software refactoring tools. However, the results of automated refactoring tools often deviate from the intentions of the implementer. The goal of this project is to propose an open-source refactoring engine and toolkit that can automatically find the best refactoring sequence required for a given software and apply this sequence. Since the tool is work based on compiler principles, it is reliable to be used in practice and has many benefits for software developer companies. Students who participate in the project will learn compiler techniques such as lexing, parsing, source code analysis, and source code transformation. They also learn about software refactoring, search-based software engineering, optimization, software quality, and object-orient metrics.","title":"8 Conclusion and remarks"},{"location":"#conflict-of-interest","text":"The project is supported by the IUST Reverse Engineering Research Laboratory . Interested students may continue working on this project to fulfill their final bachelor and master thesis or their internship.","title":"Conflict of interest"},{"location":"#references","text":"[1] T. Parr and K. Fisher, \u201cLL(*): the foundation of the ANTLR parser generator,\u201d Proc. 32nd ACM SIGPLAN Conf. Program. Lang. Des. Implement., pp. 425\u2013436, 2011. [2] M. K. B. Fowler, Refactoring: improving the design of existing code, Second Edi. Addison-Wesley, 2018. [3] M. W. Mkaouer, M. Kessentini, S. Bechikh, M. O\u0301 Cinne\u0301ide, and K. Deb, \u201cOn the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,\u201d Empir. Softw. Eng., vol. 21, no. 6, pp. 2503\u20132545, Dec. 2016. [4] M. Mohan, D. Greer, and P. McMullan, \u201cTechnical debt reduction using search based automated refactoring,\u201d J. Syst. Softw., vol. 120, pp. 183\u2013194, Oct. 2016. [5] M. Mohan and D. Greer, \u201cUsing a many-objective approach to investigate automated refactoring,\u201d Inf. Softw. Technol., vol. 112, pp. 83\u2013101, Aug. 2019. [6] W. Mkaouer et al., \u201cMany-Objective Software Remodularization Using NSGA-III,\u201d ACM Trans. Softw. Eng. Methodol., vol. 24, no. 3, pp. 1\u201345, May 2015. [7] M. Mohan and D. Greer, \u201cMultiRefactor: automated refactoring to improve software quality,\u201d 2017, pp. 556\u2013572. [8] N. Tsantalis, T. Chaikalis, and A. Chatzigeorgiou, \u201cTen years of JDeodorant: lessons learned from the hunt for smells,\u201d in 2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER), 2018, pp. 4\u201314. [9] T. Mens and T. Tourwe, \u201cA survey of software refactoring,\u201d IEEE Trans. Softw. Eng., vol. 30, no. 2, pp. 126\u2013139, Feb. 2004.","title":"References"},{"location":"#related-links","text":"IUST compiler course official webpage ANTLR slides: PART 1: Introduction ANTLR slides: PART 2: Getting started in Java ANTLR slides: PART 3: Getting started in C#","title":"Related links"},{"location":"#endnotes","text":"[1] https://www.jetbrains.com/idea/ [2] http://www.eclipse.org [3] http://www.netbeans.org [4] https://github.com/mmohan01/MultiRefactor [5] http://sourceforge.net/projects/recoder [6] http://reverse.iust.ac.ir","title":"Endnotes"},{"location":"about/","text":"About us Programming is the art of telling another human being what one wants the computer to do. \u2014 Donald Knuth Project contributors Who are behind CodART? The CodART Project is part of Morteza Zakeri\u2019s Ph.D. thesis to refactor Java source codes automatically and improve their testability. We have also defined several sub-projects relevant to CodART to improve software quality. Project owner Morteza ZAKERI , Ph.D. student at Iran University of Science and Technology Project supervisor Dr. Saeed Parsa Associate professor at Iran University of Science and Technology Dr. Mehrdad Ashtiani Assistant professor at Iran University of Science and Technology Current contributors Seyyed Ali Ayati, B.Sc. student at Iran University of Science and Technology Mina Tahaei, B.Sc. student at Iran University of Science and Technology Former contributors IUST B.Sc. students in Compiler course (Fall 2020) IUST M.Sc. students in Advanced Compiler course (Fall 2020) More For any question please contact m-zakeri@live.com or visit CodART repo on GitHub: https://github.com/m-zakeri/CodART","title":"About us"},{"location":"about/#about-us","text":"Programming is the art of telling another human being what one wants the computer to do. \u2014 Donald Knuth","title":"About us"},{"location":"about/#project-contributors","text":"Who are behind CodART? The CodART Project is part of Morteza Zakeri\u2019s Ph.D. thesis to refactor Java source codes automatically and improve their testability. We have also defined several sub-projects relevant to CodART to improve software quality.","title":"Project contributors"},{"location":"about/#project-owner","text":"Morteza ZAKERI , Ph.D. student at Iran University of Science and Technology","title":"Project owner"},{"location":"about/#project-supervisor","text":"Dr. Saeed Parsa Associate professor at Iran University of Science and Technology Dr. Mehrdad Ashtiani Assistant professor at Iran University of Science and Technology","title":"Project supervisor"},{"location":"about/#current-contributors","text":"Seyyed Ali Ayati, B.Sc. student at Iran University of Science and Technology Mina Tahaei, B.Sc. student at Iran University of Science and Technology","title":"Current contributors"},{"location":"about/#former-contributors","text":"IUST B.Sc. students in Compiler course (Fall 2020) IUST M.Sc. students in Advanced Compiler course (Fall 2020)","title":"Former contributors"},{"location":"about/#more","text":"For any question please contact m-zakeri@live.com or visit CodART repo on GitHub: https://github.com/m-zakeri/CodART","title":"More"},{"location":"benchmarks/","text":"CodART benchmarks and testbed To ensure CodART works properly, we are running it on many real-life software projects. Refactorings are applied to the software systems listed in Table 3. Benchmark projects may update and extend in the future. For the time being, we use a set of well-known open-source Java projects that have been intensely studied in previous works. We have also added two new Java software programs, WEKA and ANTLR, to examine the versatility of CodART performance on real-life software projects. Table 3. Software systems used as benchmarks in CodeART System Release Previous releases Domain Reference Xerces-J v2.7.0 -- software packages for parsing XML [3], [6] Azureus v2.3.0.6 -- Java BitTorrent client for handling multiple torrents [3] ArgoUML v0.26 and v0.3 -- UML tool for object-oriented design [3] Apache Ant v1.5.0 and v1.7.0 -- Java build tool and library [3] GanttProject v1.10.2 and v1.11.1 -- project management [3], [6], [5] JHotDraw v6.1 and v6.0b1 and v5.3 -- graphics tool [6], [5], [4] JFreeChart v1.0.9 -- chart tool [6] Beaver v0.9.11 and v0.9.8 -- parser generator [5], [4] Apache XML-RPC v3.1.1 -- B2B communications [5], [4] JRDF v0.3.4.3 -- semantic web (resource management) [5] XOM v1.2.1 -- XML tool [5] JSON v1.1 -- software packages for parsing JSON [4] JFlex v1.4.1 -- lexical analyzer generator [4] Mango v2.0.1 -- -- [4] Weka v3.9 -- data mining tool New ANTLR v4.8.0 -- parser generator tool New New projects To be announced. References [3] M. W. Mkaouer, M. Kessentini, S. Bechikh, M. O\u0301 Cinne\u0301ide, and K. Deb, \u201cOn the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,\u201d Empir. Softw. Eng., vol. 21, no. 6, pp. 2503\u20132545, Dec. 2016. [4] M. Mohan, D. Greer, and P. McMullan, \u201cTechnical debt reduction using search based automated refactoring,\u201d J. Syst. Softw., vol. 120, pp. 183\u2013194, Oct. 2016. [5] M. Mohan and D. Greer, \u201cUsing a many-objective approach to investigate automated refactoring,\u201d Inf. Softw. Technol., vol. 112, pp. 83\u2013101, Aug. 2019. [6] W. Mkaouer et al., \u201cMany-Objective Software Remodularization Using NSGA-III,\u201d ACM Trans. Softw. Eng. Methodol., vol. 24, no. 3, pp. 1\u201345, May 2015.","title":"Benchmarks"},{"location":"benchmarks/#codart-benchmarks-and-testbed","text":"To ensure CodART works properly, we are running it on many real-life software projects. Refactorings are applied to the software systems listed in Table 3. Benchmark projects may update and extend in the future. For the time being, we use a set of well-known open-source Java projects that have been intensely studied in previous works. We have also added two new Java software programs, WEKA and ANTLR, to examine the versatility of CodART performance on real-life software projects. Table 3. Software systems used as benchmarks in CodeART System Release Previous releases Domain Reference Xerces-J v2.7.0 -- software packages for parsing XML [3], [6] Azureus v2.3.0.6 -- Java BitTorrent client for handling multiple torrents [3] ArgoUML v0.26 and v0.3 -- UML tool for object-oriented design [3] Apache Ant v1.5.0 and v1.7.0 -- Java build tool and library [3] GanttProject v1.10.2 and v1.11.1 -- project management [3], [6], [5] JHotDraw v6.1 and v6.0b1 and v5.3 -- graphics tool [6], [5], [4] JFreeChart v1.0.9 -- chart tool [6] Beaver v0.9.11 and v0.9.8 -- parser generator [5], [4] Apache XML-RPC v3.1.1 -- B2B communications [5], [4] JRDF v0.3.4.3 -- semantic web (resource management) [5] XOM v1.2.1 -- XML tool [5] JSON v1.1 -- software packages for parsing JSON [4] JFlex v1.4.1 -- lexical analyzer generator [4] Mango v2.0.1 -- -- [4] Weka v3.9 -- data mining tool New ANTLR v4.8.0 -- parser generator tool New","title":"CodART benchmarks and testbed"},{"location":"benchmarks/#new-projects","text":"To be announced.","title":"New projects"},{"location":"benchmarks/#references","text":"[3] M. W. Mkaouer, M. Kessentini, S. Bechikh, M. O\u0301 Cinne\u0301ide, and K. Deb, \u201cOn the use of many quality attributes for software refactoring: a many-objective search-based software engineering approach,\u201d Empir. Softw. Eng., vol. 21, no. 6, pp. 2503\u20132545, Dec. 2016. [4] M. Mohan, D. Greer, and P. McMullan, \u201cTechnical debt reduction using search based automated refactoring,\u201d J. Syst. Softw., vol. 120, pp. 183\u2013194, Oct. 2016. [5] M. Mohan and D. Greer, \u201cUsing a many-objective approach to investigate automated refactoring,\u201d Inf. Softw. Technol., vol. 112, pp. 83\u2013101, Aug. 2019. [6] W. Mkaouer et al., \u201cMany-Objective Software Remodularization Using NSGA-III,\u201d ACM Trans. Softw. Eng. Methodol., vol. 24, no. 3, pp. 1\u201345, May 2015.","title":"References"},{"location":"code_smells_list/","text":"Code smells list The following code smells are detected by CodART. Table 2. Code smells Code smell Descriptions and other names God class The class defines many data members (fields) and methods and exhibits low cohesion. The god class smell occurs when a huge class surrounded by many data classes acts as a controller (i.e., takes most of the decisions and monopolizes the software's functionality). Other names: Blob, large class, brain class. Long method This smell occurs when a method is too long to understand and most presumably perform more than one responsibility. Other names: God method, brain method, large method. Feature envy This smell occurs when a method seems more interested in a class other than the one it actually is in. Data class This smell occurs when a class contains only fields and possibly getters/setters without any behavior (methods). Shotgun surgery This smell characterizes the situation when one kind of change leads to many changes to multiple different classes. When the changes are all over the place, they are hard to find, and it is easy to miss a necessary change. Refused bequest This smell occurs when a subclass rejects some of the methods or properties offered by its superclass. Functional decomposition This smell occurs when the experienced developers coming from procedural languages background write highly procedural and non-object-oriented code in an object-oriented language. Long parameter list This smell occurs when a method accepts a long list of parameters. Such lists are hard to understand and difficult to use. Promiscuous package A package can be considered promiscuous if it contains classes implementing too many features, making it too hard to understand and maintain. As for god class and long method, this smell arises when the package has low cohesion since it manages different responsibilities. Misplaced class A Misplaced Class smell suggests a class that is in a package that contains other classes not related to it. Switch statement This smell occurs when switch statements that switch on type codes are spread across the software system instead of exploiting polymorphism. Spaghetti code This smell refers to an unmaintainable, incomprehensible code without any structure. The smell does not exploit and prevents the use of object-orientation mechanisms and concepts. Divergent change Divergent change occurs when one class is commonly changed in different ways for different reasons. Other names: Multifaceted abstraction Deficient encapsulation This smell occurs when the declared accessibility of one or more members of abstraction is more permissive than actually required. Swiss army knife This smell arises when the designer attempts to provide all possible uses of the class and ends up in an excessively complex class interface. Lazy class Unnecessary abstraction Cyclically-dependent modularization This smell arises when two or more abstractions depend on each other directly or indirectly. Primitive obsession This smell occurs when primitive data types are used where an abstraction encapsulating the primitives could serve better. Speculative generality This smell occurs where abstraction is created based on speculated requirements. It is often unnecessary that makes things difficult to understand and maintain. Message chains A message chain occurs when a client requests another object, that object requests yet another one, and so on. These chains mean that the client is dependent on navigation along with the class structure. Any changes in these relationships require modifying the client. Total 20","title":"Code smell list"},{"location":"code_smells_list/#code-smells-list","text":"The following code smells are detected by CodART. Table 2. Code smells Code smell Descriptions and other names God class The class defines many data members (fields) and methods and exhibits low cohesion. The god class smell occurs when a huge class surrounded by many data classes acts as a controller (i.e., takes most of the decisions and monopolizes the software's functionality). Other names: Blob, large class, brain class. Long method This smell occurs when a method is too long to understand and most presumably perform more than one responsibility. Other names: God method, brain method, large method. Feature envy This smell occurs when a method seems more interested in a class other than the one it actually is in. Data class This smell occurs when a class contains only fields and possibly getters/setters without any behavior (methods). Shotgun surgery This smell characterizes the situation when one kind of change leads to many changes to multiple different classes. When the changes are all over the place, they are hard to find, and it is easy to miss a necessary change. Refused bequest This smell occurs when a subclass rejects some of the methods or properties offered by its superclass. Functional decomposition This smell occurs when the experienced developers coming from procedural languages background write highly procedural and non-object-oriented code in an object-oriented language. Long parameter list This smell occurs when a method accepts a long list of parameters. Such lists are hard to understand and difficult to use. Promiscuous package A package can be considered promiscuous if it contains classes implementing too many features, making it too hard to understand and maintain. As for god class and long method, this smell arises when the package has low cohesion since it manages different responsibilities. Misplaced class A Misplaced Class smell suggests a class that is in a package that contains other classes not related to it. Switch statement This smell occurs when switch statements that switch on type codes are spread across the software system instead of exploiting polymorphism. Spaghetti code This smell refers to an unmaintainable, incomprehensible code without any structure. The smell does not exploit and prevents the use of object-orientation mechanisms and concepts. Divergent change Divergent change occurs when one class is commonly changed in different ways for different reasons. Other names: Multifaceted abstraction Deficient encapsulation This smell occurs when the declared accessibility of one or more members of abstraction is more permissive than actually required. Swiss army knife This smell arises when the designer attempts to provide all possible uses of the class and ends up in an excessively complex class interface. Lazy class Unnecessary abstraction Cyclically-dependent modularization This smell arises when two or more abstractions depend on each other directly or indirectly. Primitive obsession This smell occurs when primitive data types are used where an abstraction encapsulating the primitives could serve better. Speculative generality This smell occurs where abstraction is created based on speculated requirements. It is often unnecessary that makes things difficult to understand and maintain. Message chains A message chain occurs when a client requests another object, that object requests yet another one, and so on. These chains mean that the client is dependent on navigation along with the class structure. Any changes in these relationships require modifying the client. Total 20","title":"Code smells list"},{"location":"faq/","text":"Frequently asked question Q1: What is CodART? A1: CodART is an automated source code refactoring toolkit. Q2: How can I contribute to the CodART project? A2: For any other question please contact us at m-zakeri@live.com","title":"FAQ"},{"location":"faq/#frequently-asked-question","text":"Q1: What is CodART? A1: CodART is an automated source code refactoring toolkit. Q2: How can I contribute to the CodART project? A2: For any other question please contact us at m-zakeri@live.com","title":"Frequently asked question"},{"location":"publications/","text":"Publications [1] Nasrabadi, M. Z., & Parsa, S. (2021). Learning to predict software testability. In 26th International Computer Conference, Computer Society of Iran. Tehran: IEEE. [2] [3]","title":"Publications"},{"location":"publications/#publications","text":"[1] Nasrabadi, M. Z., & Parsa, S. (2021). Learning to predict software testability. In 26th International Computer Conference, Computer Society of Iran. Tehran: IEEE. [2] [3]","title":"Publications"},{"location":"refactorings_list/","text":"Refactoring list The following refactoring operations have been automated in CodART. Click on refactoring name to see the API and code. Table 1. Refactoring operations Refactoring Definition Entities Roles Move class Move a class from a package to another package class source package, target package moved class Move method Move a method from a class to another. class method source class, target class moved method Merge packages Merge the elements of a set of packages in one of them package source package, target package Extract/Split package Add a package to compose the elements of another package package source package, target package Extract class Create a new class and move fields and methods from the old class to the new one class method source class, new class moved methods Extract method Extract a code fragment into a method method statement source method, new method moved statements Inline class Move all features of a class in another one and remove it class source class, target class Move field Move a field from a class to another class field source class, target class field Push down field Move a field of a superclass to a subclass class field super class, sub classes move field Push down method Move a method of a superclass to a subclass class method super class, sub classes moved method Pull up field Move a field from subclasses to the superclass class field sub classes, super class moved field Pull up method Move a method from subclasses to the superclass class method sub classes, super class moved method Increase field visibility Increase the visibility of a field from public to protected, protected to package or package to private class field source class source filed Decrease field visibility Decrease the visibility of a field from private to package, package to protected or protected to public class field source class source filed Make field final Make a non-final field final class field source class source filed Make field non-final Make a final field non-final class field source class source filed Make field static Make a non-static field static class field source class source filed Make field non-static Make a static field non-static class field source class source filed Remove field Remove a field from a class class field source class source filed Increase method visibility Increase the visibility of a method from public to protected, protected to package or package to private class method source class source method Decrease method visibility Decrease the visibility of a method from private to package, package to protected or protected to public class method source class source method Make method final Make a non-final method final class method source class source method Make method non-final Make a final method non-final class method source class source method Make method static Make a non-static method static class method source class source method Make method non-static Make a static method non-static class method source class source method Remove method Remove a method from a class class method source class source method Make class-final Make a non-final class final class source class Make class non-final Make a final class non-final class source class Make class abstract Change a concrete class to abstract class source class Make class concrete Change an abstract class to concrete class source class Extract subclass Create a subclass for a set of features class method source class, new subclass moved methods Extract interface Extract methods of a class into an interface class method source class, new interface interface methods Inline method Move the body of a method into its callers and remove the method method source method, callers method Collapse hierarchy Merge a superclass and a subclass class superclass, subclass Remove control flag Replace control flag with a break class method source class source method Replace nested conditional with guard clauses Replace nested conditional with guard clauses class method source class source method Replace constructor with a factory function Replace constructor with a factory function class source class Replace exception with test Replace exception with precheck class method source class source method Rename field Rename a field class field source class source filed Rename method Rename a method class method source class source method Rename class Rename a class class source class Rename package Rename a package package source package Encapsulate field Create setter/mutator and getter/accessor methods for a private field class field source class source filed Replace parameter with query Replace parameter with query class method source class source method Pull up constructor body Move the constructor class method subclass class, superclass constructor Replace control flag with break Replace control flag with break class method source class source method Remove flag argument Remove flag argument class method source class source method Total 47 \u2014 \u2014","title":"Refactoring list"},{"location":"refactorings_list/#refactoring-list","text":"The following refactoring operations have been automated in CodART. Click on refactoring name to see the API and code. Table 1. Refactoring operations Refactoring Definition Entities Roles Move class Move a class from a package to another package class source package, target package moved class Move method Move a method from a class to another. class method source class, target class moved method Merge packages Merge the elements of a set of packages in one of them package source package, target package Extract/Split package Add a package to compose the elements of another package package source package, target package Extract class Create a new class and move fields and methods from the old class to the new one class method source class, new class moved methods Extract method Extract a code fragment into a method method statement source method, new method moved statements Inline class Move all features of a class in another one and remove it class source class, target class Move field Move a field from a class to another class field source class, target class field Push down field Move a field of a superclass to a subclass class field super class, sub classes move field Push down method Move a method of a superclass to a subclass class method super class, sub classes moved method Pull up field Move a field from subclasses to the superclass class field sub classes, super class moved field Pull up method Move a method from subclasses to the superclass class method sub classes, super class moved method Increase field visibility Increase the visibility of a field from public to protected, protected to package or package to private class field source class source filed Decrease field visibility Decrease the visibility of a field from private to package, package to protected or protected to public class field source class source filed Make field final Make a non-final field final class field source class source filed Make field non-final Make a final field non-final class field source class source filed Make field static Make a non-static field static class field source class source filed Make field non-static Make a static field non-static class field source class source filed Remove field Remove a field from a class class field source class source filed Increase method visibility Increase the visibility of a method from public to protected, protected to package or package to private class method source class source method Decrease method visibility Decrease the visibility of a method from private to package, package to protected or protected to public class method source class source method Make method final Make a non-final method final class method source class source method Make method non-final Make a final method non-final class method source class source method Make method static Make a non-static method static class method source class source method Make method non-static Make a static method non-static class method source class source method Remove method Remove a method from a class class method source class source method Make class-final Make a non-final class final class source class Make class non-final Make a final class non-final class source class Make class abstract Change a concrete class to abstract class source class Make class concrete Change an abstract class to concrete class source class Extract subclass Create a subclass for a set of features class method source class, new subclass moved methods Extract interface Extract methods of a class into an interface class method source class, new interface interface methods Inline method Move the body of a method into its callers and remove the method method source method, callers method Collapse hierarchy Merge a superclass and a subclass class superclass, subclass Remove control flag Replace control flag with a break class method source class source method Replace nested conditional with guard clauses Replace nested conditional with guard clauses class method source class source method Replace constructor with a factory function Replace constructor with a factory function class source class Replace exception with test Replace exception with precheck class method source class source method Rename field Rename a field class field source class source filed Rename method Rename a method class method source class source method Rename class Rename a class class source class Rename package Rename a package package source package Encapsulate field Create setter/mutator and getter/accessor methods for a private field class field source class source filed Replace parameter with query Replace parameter with query class method source class source method Pull up constructor body Move the constructor class method subclass class, superclass constructor Replace control flag with break Replace control flag with break class method source class source method Remove flag argument Remove flag argument class method source class source method Total 47 \u2014 \u2014","title":"Refactoring list"},{"location":"code_smells/feature_envy/","text":"Feature envy To be constructed...","title":"Feature envy"},{"location":"code_smells/feature_envy/#feature-envy","text":"To be constructed...","title":"Feature envy"},{"location":"code_smells/large_class/","text":"Large class To be constructed...","title":"Large class"},{"location":"code_smells/large_class/#large-class","text":"To be constructed...","title":"Large class"},{"location":"code_smells/long_method/","text":"Long method To be constructed...","title":"Long method"},{"location":"code_smells/long_method/#long-method","text":"To be constructed...","title":"Long method"},{"location":"proposals/core_code_smell_development/","text":"Core code smell development The following proposal has been initially prepared for the IUST Compiler and Advanced Software Engineering courses in Winter and Spring 2021 . Note: Before reading this proposal ensure that you have read and understood the CodART white-paper . Students may form groups of up to three persons. Each group must develop mechanisms for a subset of code smells listed in Table 2 . The exact list of code smells will be assigned to each group subsequently. The refactoring operations in Table 1 and code smells in Table 2 may update during the semester. To facilitate and organized the development process, this proposal defines the project in various phases. The project is divided into three separate phases. In the first phase, students must read about refactoring and code smells and understand the current state of the CodART completely. As a practice, they are asked to fix the existing issues on the project repository about refactoring operations developed in the first proposal. In the second phase, each group is asked to develop algorithms to automatically detect one or more code smells in a given Java project using ANTLR tool and other compiler techniques. TA team frequently helps the students at this phase to develop their algorithms. In the third phase, each group is asked to connect the code smells detection scripts to the corresponding refactoring and automate the overall quality improvement process. Grading policy for BSc students Table 6 shows the grading policy for the BSc students. It may change in the future. Table 6. grading policy for BSc students Activity Score (100) Understanding the CodART project and Fix the existing issues 30 Implementing smell detection approaches 40 Connecting code smells to refactoring and harnessing the overall process 20 Documenting the new source codes and pushing them to GitHub 10 Testing project on all projects available in CodART benchmarks 20+ (extra bonus) Grading policy for MSc students Table 7 shows the grading policy for the MSc students. It may change in the future. Table 7. grading policy for MSc students Activity Score (100) Understanding the paper and presenting it 20 Implementing the paper 30 Evaluating the implementation 30 Documenting the project 20 Testing project on all projects available in CodART benchmarks 20+ (extra bonus) To follow project's future phases, meet our next proposal: Core search-based development.","title":"Core code smell development"},{"location":"proposals/core_code_smell_development/#core-code-smell-development","text":"The following proposal has been initially prepared for the IUST Compiler and Advanced Software Engineering courses in Winter and Spring 2021 . Note: Before reading this proposal ensure that you have read and understood the CodART white-paper . Students may form groups of up to three persons. Each group must develop mechanisms for a subset of code smells listed in Table 2 . The exact list of code smells will be assigned to each group subsequently. The refactoring operations in Table 1 and code smells in Table 2 may update during the semester. To facilitate and organized the development process, this proposal defines the project in various phases. The project is divided into three separate phases. In the first phase, students must read about refactoring and code smells and understand the current state of the CodART completely. As a practice, they are asked to fix the existing issues on the project repository about refactoring operations developed in the first proposal. In the second phase, each group is asked to develop algorithms to automatically detect one or more code smells in a given Java project using ANTLR tool and other compiler techniques. TA team frequently helps the students at this phase to develop their algorithms. In the third phase, each group is asked to connect the code smells detection scripts to the corresponding refactoring and automate the overall quality improvement process.","title":"Core code smell development"},{"location":"proposals/core_code_smell_development/#grading-policy-for-bsc-students","text":"Table 6 shows the grading policy for the BSc students. It may change in the future. Table 6. grading policy for BSc students Activity Score (100) Understanding the CodART project and Fix the existing issues 30 Implementing smell detection approaches 40 Connecting code smells to refactoring and harnessing the overall process 20 Documenting the new source codes and pushing them to GitHub 10 Testing project on all projects available in CodART benchmarks 20+ (extra bonus)","title":"Grading policy for BSc students"},{"location":"proposals/core_code_smell_development/#grading-policy-for-msc-students","text":"Table 7 shows the grading policy for the MSc students. It may change in the future. Table 7. grading policy for MSc students Activity Score (100) Understanding the paper and presenting it 20 Implementing the paper 30 Evaluating the implementation 30 Documenting the project 20 Testing project on all projects available in CodART benchmarks 20+ (extra bonus) To follow project's future phases, meet our next proposal: Core search-based development.","title":"Grading policy for MSc students"},{"location":"proposals/core_refactoring_to_design_patterns_development/","text":"Core refactoring to design patterns development To be announced.","title":"Core refactoring to patterns development"},{"location":"proposals/core_refactoring_to_design_patterns_development/#core-refactoring-to-design-patterns-development","text":"To be announced.","title":"Core refactoring to design patterns development"},{"location":"proposals/core_refactorings_development/","text":"Core refactoring development The following proposal was initially prepared for the IUST Compiler and Advanced compiler courses in Fall 2020. Students must form groups of up to three persons, and each group must implement several refactoring operations. The exact list of refactoring will be assigned to each group subsequently. The refactoring operations in Table 1 may update during the semester. As an example of refactoring automation, we have implemented the EncapsulateField refactoring, illustrated in Figure 1. A na\u00efve implementation is available on the project official Github page at https://m-zakeri.github.io/CodART . In addition, 26 refactoring operations in Table 1 have been implemented by MultiRefactor [7] based on RECODER , three of them have been implemented by JDeodrant [8], and other operations have been automated in [3], [6]. RECODER extracts a model of the code that can be used to analyze and modify the code before the changes are applied and written to file. The tool takes Java source code as input and will output the modified source code to a specified folder. The input must be fully compilable and must be accompanied by any necessary library files as compressed jar files. Grading policy for BSc students Table 4 shows the grading policy for the BSc students. It may change in the future. Table 4. grading policy for BSc students Activity Score (100) Refactoring operations implementation (moderate level) 50 Evaluation of the tool on the benchmark projects 30 Documentations 20 Search-based refactoring recommendation 30+ (extra bonus) Grading policy for MSc students Table 5 shows the grading policy for the MSc students. It may change in the future. Table 5. grading policy for MSc students Activity Score (100) Refactoring operations implementation (advanced level) 40 Search-based refactoring recommendation 30 Evaluation of the tool on the benchmark projects 20 Documentations 10 Improving the state-of-the-arts papers 30+ (extra bonus) To follow project's phases, refer to our next proposal: Core code smell development.","title":"Core refactoring development"},{"location":"proposals/core_refactorings_development/#core-refactoring-development","text":"The following proposal was initially prepared for the IUST Compiler and Advanced compiler courses in Fall 2020. Students must form groups of up to three persons, and each group must implement several refactoring operations. The exact list of refactoring will be assigned to each group subsequently. The refactoring operations in Table 1 may update during the semester. As an example of refactoring automation, we have implemented the EncapsulateField refactoring, illustrated in Figure 1. A na\u00efve implementation is available on the project official Github page at https://m-zakeri.github.io/CodART . In addition, 26 refactoring operations in Table 1 have been implemented by MultiRefactor [7] based on RECODER , three of them have been implemented by JDeodrant [8], and other operations have been automated in [3], [6]. RECODER extracts a model of the code that can be used to analyze and modify the code before the changes are applied and written to file. The tool takes Java source code as input and will output the modified source code to a specified folder. The input must be fully compilable and must be accompanied by any necessary library files as compressed jar files.","title":"Core refactoring development"},{"location":"proposals/core_refactorings_development/#grading-policy-for-bsc-students","text":"Table 4 shows the grading policy for the BSc students. It may change in the future. Table 4. grading policy for BSc students Activity Score (100) Refactoring operations implementation (moderate level) 50 Evaluation of the tool on the benchmark projects 30 Documentations 20 Search-based refactoring recommendation 30+ (extra bonus)","title":"Grading policy for BSc students"},{"location":"proposals/core_refactorings_development/#grading-policy-for-msc-students","text":"Table 5 shows the grading policy for the MSc students. It may change in the future. Table 5. grading policy for MSc students Activity Score (100) Refactoring operations implementation (advanced level) 40 Search-based refactoring recommendation 30 Evaluation of the tool on the benchmark projects 20 Documentations 10 Improving the state-of-the-arts papers 30+ (extra bonus) To follow project's phases, refer to our next proposal: Core code smell development.","title":"Grading policy for MSc students"},{"location":"proposals/core_search_based_development/","text":"Core search-based development To be announced.","title":"Core serach-based development"},{"location":"proposals/core_search_based_development/#core-search-based-development","text":"To be announced.","title":"Core search-based development"},{"location":"refactorings/decrease_field_visibility/","text":"Decrease field visibility Introduction: Decrease the visibility of a field from public to protected, protected to package or package to private. Pre and Post Conditions Pre Conditions: User must enter the field's name, and the source class's name for the refactoring in order to decrease the target field's visibility. Post Conditions: No specific Post Condition __init__ ( self , common_token_stream = None , source_class = None , field_name = None ) special To implement \u0650Decrease Field Visibility refactoring based on its actors. Detects the required field and decreases/changes its visibility status. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose visibility status has to be changed None Returns: Type Description No returns Source code in refactorings\\decrease_field_visibility.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\" To implement \u0650Decrease Field Visibility refactoring based on its actors. Detects the required field and decreases/changes its visibility status. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose visibility status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . detected_field = None self . detected_method = None self . TAB = \" \\t \" self . NEW_LINE = \" \\n \" self . code = \"\" self . tempdeclarationcode = \"\"","title":"Decrease field visibility"},{"location":"refactorings/decrease_field_visibility/#decrease-field-visibility","text":"","title":"Decrease field visibility"},{"location":"refactorings/decrease_field_visibility/#refactorings.decrease_field_visibility.DecreaseFieldVisibilityRefactoringListener--introduction","text":"Decrease the visibility of a field from public to protected, protected to package or package to private.","title":"Introduction:"},{"location":"refactorings/decrease_field_visibility/#refactorings.decrease_field_visibility.DecreaseFieldVisibilityRefactoringListener--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/decrease_field_visibility/#refactorings.decrease_field_visibility.DecreaseFieldVisibilityRefactoringListener--pre-conditions","text":"User must enter the field's name, and the source class's name for the refactoring in order to decrease the target field's visibility.","title":"Pre Conditions:"},{"location":"refactorings/decrease_field_visibility/#refactorings.decrease_field_visibility.DecreaseFieldVisibilityRefactoringListener--post-conditions","text":"No specific Post Condition","title":"Post Conditions:"},{"location":"refactorings/decrease_field_visibility/#refactorings.decrease_field_visibility.DecreaseFieldVisibilityRefactoringListener.__init__","text":"To implement \u0650Decrease Field Visibility refactoring based on its actors. Detects the required field and decreases/changes its visibility status. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose visibility status has to be changed None Returns: Type Description No returns Source code in refactorings\\decrease_field_visibility.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\" To implement \u0650Decrease Field Visibility refactoring based on its actors. Detects the required field and decreases/changes its visibility status. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose visibility status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . detected_field = None self . detected_method = None self . TAB = \" \\t \" self . NEW_LINE = \" \\n \" self . code = \"\" self . tempdeclarationcode = \"\"","title":"__init__()"},{"location":"refactorings/extract_interface/","text":"Extract interface Introduction When multiple clients are using the same part of a class interface, or part of the interface in two classes is the same; Extract Interface Refactoring moves this identical portion to its own interface. Pre and Post Conditions Pre Conditions: precondition is whether the package name, all the class names and method names in those classes exist. The parameter types and return types of each method should be the same across the classes. Post Conditions: No specific Post Condition extract_interface ( source_filenames , package_name , class_names , method_keys , interface_name , interface_filename , filename_mapping =< function < lambda > at 0x0000015D74753160 > ) The main function that does the process of extract interface refactoring. Splits the identical,reused portion of the interface, creates a new interface, and moves the split portion to the new interface. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the classes) required class_names list The classes which are going to implement the new interface required method_keys list The methods which are going to be included in the interface required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D74753160> interface_name str The new interface name required interface_filename str The new interface file name required Returns: Type Description bool No returns Source code in refactorings\\extract_interface.py def extract_interface ( source_filenames : list , package_name : str , class_names : list , method_keys : list , interface_name : str , interface_filename : str , filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of extract interface refactoring. Splits the identical,reused portion of the interface, creates a new interface, and moves the split portion to the new interface. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the classes) class_names (str): The classes which are going to implement the new interface method_keys (str): The methods which are going to be included in the interface filename_mapping (str): Mapping the file's name to the correct format so that it can be processed interface_name (str): The new interface name interface_filename (str): The new interface file name Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) if package_name not in program . packages \\ or any ( class_name not in program . packages [ package_name ] . classes for class_name in class_names ) \\ or any ( method_key not in program . packages [ package_name ] . classes [ class_name ] . methods for class_name in class_names for method_key in method_keys ): return False method_returntypes = {} method_parameters = {} method_names = [] for method_key in method_keys : method_names . append ( method_key [: method_key . find ( '(' )]) rewriter = utils2 . Rewriter ( program , filename_mapping ) for class_name in class_names : c : utils_listener_fast . Class = program . packages [ package_name ] . classes [ class_name ] # Add implements to the class has_superinterface = False if c . parser_context . IMPLEMENTS () is not None : # old: c.parser_context.superinterfaces() t = utils_listener_fast . TokensInfo ( c . parser_context . typeList ()) # old: c.parser_context.superinterfaces() has_superinterface = True elif c . parser_context . EXTENDS () is not None : # old: c.parser_context.superclass() t = utils_listener_fast . TokensInfo ( c . parser_context . typeType ()) # old: c.parser_context.superclass() elif c . parser_context . typeParameters () is not None : t = utils_listener_fast . TokensInfo ( c . parser_context . typeParameters ()) else : # old: TokensInfo(c.parser_context.identifier()) t = utils_listener_fast . TokensInfo ( c . parser_context ) t . stop = c . parser_context . IDENTIFIER () . getSymbol () . tokenIndex rewriter . insert_after ( t , ( \", \" if has_superinterface else \" implements \" ) + interface_name ) for method_key in method_keys : m : utils_listener_fast . Method = c . methods [ method_key ] # Check if the return types / parameter types are the same # Or add to dictionary if method_key in method_returntypes : if method_returntypes [ method_key ] != m . returntype : return False if len ( method_parameters [ method_key ]) != len ( m . parameters ): return False for i in range ( len ( m . parameters )): if method_parameters [ method_key ][ i ][ 0 ] != m . parameters [ i ][ 0 ]: return False else : method_returntypes [ method_key ] = m . returntype method_parameters [ method_key ] = m . parameters # Manage method modifiers if len ( m . modifiers_parser_contexts ) > 0 : t = utils_listener_fast . TokensInfo ( m . modifiers_parser_contexts [ 0 ]) else : t = m . get_tokens_info () rewriter . insert_before_start ( t , # old: m.get_tokens_info() # without requiring t ( \"\" if \"@Override\" in m . modifiers else \"@Override \\n \" ) + ( \"\" if \"public\" in m . modifiers else \"public \" ) ) for i in range ( len ( m . modifiers )): mm = m . modifiers [ i ] if mm == \"private\" or mm == \"protected\" : t = utils_listener_fast . TokensInfo ( m . modifiers_parser_contexts [ i ]) # old: m.parser_context.methodModifier(i) rewriter . replace ( t , \"\" ) # Change variable types to the interface if only interface methods are used. for package_name in program . packages : p : utils_listener_fast . Package = program . packages [ package_name ] for class_name in p . classes : c : utils_listener_fast . Class = p . classes [ class_name ] fields_of_interest = {} for fn in c . fields : f : utils_listener_fast . Field = c . fields [ fn ] d = False for cn in class_names : if ( f . datatype == cn and f . file_info . has_imported_class ( package_name , cn )) \\ or ( package_name is not None and f . datatype == package_name + '.' + cn ): d = True break if d and \"private\" in f . modifiers : fields_of_interest [ f . name ] = f for method_key in c . methods : m : utils_listener_fast . Method = c . methods [ method_key ] vars_of_interest = {} for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . LocalVariable ): for cn in class_names : if ( item . datatype == cn and c . file_info . has_imported_class ( package_name , cn )) \\ or ( package_name is not None and item . datatype == package_name + '.' + cn ): vars_of_interest [ item . identifier ] = item break if isinstance ( item , utils_listener_fast . MethodInvocation ): if len ( item . dot_separated_identifiers ) == 2 or \\ ( len ( item . dot_separated_identifiers ) == 3 and item . dot_separated_identifiers [ 0 ] == \"this\" ): if item . dot_separated_identifiers [ - 2 ] in vars_of_interest : if item . dot_separated_identifiers [ - 1 ] not in method_names : vars_of_interest . pop ( item . dot_separated_identifiers [ - 2 ]) elif item . dot_separated_identifiers [ - 2 ] in fields_of_interest \\ and item . dot_separated_identifiers [ - 1 ] not in method_names : fields_of_interest . pop ( item . dot_separated_identifiers [ - 2 ]) for var_name in vars_of_interest : var = vars_of_interest [ var_name ] if m . file_info . has_imported_package ( package_name ): # old: var.parser_context.unannType() rewriter . replace ( utils_listener_fast . TokensInfo ( var . parser_context . typeType ()), interface_name ) else : if package_name is None : break # old: var.parser_context.unannType() rewriter . replace ( utils_listener_fast . TokensInfo ( var . parser_context . typeType ()), package_name + '.' + interface_name ) for field_name in fields_of_interest : f = fields_of_interest [ field_name ] if c . file_info . has_imported_package ( package_name ): typename = interface_name else : if package_name is None : break typename = package_name + '.' + interface_name if len ( f . neighbor_names ) == 0 : rewriter . replace ( utils_listener_fast . TokensInfo ( f . parser_context . typeType ()), typename ) # old: f.parser_context.unannType() else : if not any ( nn in fields_of_interest for nn in f . neighbor_names ): t = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators ]) if f . index_in_variable_declarators == 0 : t . stop = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators + 1 ]) . start - 1 else : t . start = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators - 1 ]) . start + 1 rewriter . replace ( t , \"\" ) rewriter . insert_after ( f . get_tokens_info (), \" \\n private \" + typename + \" \" + f . name + ( \" = \" + f . initializer + \";\" if f . initializer is not None else \";\" ) ) # Create the interface interface_file_content = ( \"package \" + package_name + \"; \\n\\n \" + \"public interface \" + interface_name + \" \\n \" + \"{ \\n \" ) for method_key in method_keys : method_name = method_key [: method_key . find ( '(' )] interface_file_content += \" \" + method_returntypes [ method_key ] + \" \" + method_name + \"(\" if len ( method_parameters [ method_key ]) > 0 : interface_file_content += method_parameters [ method_key ][ 0 ][ 0 ] + \" \" + method_parameters [ method_key ][ 0 ][ 1 ] for i in range ( 1 , len ( method_parameters [ method_key ])): param = method_parameters [ method_key ][ i ] interface_file_content += \", \" + param [ 0 ] + \" \" + param [ 1 ] interface_file_content += \"); \\n \" interface_file_content += \"} \\n \" if not os . path . exists ( interface_filename [: interface_filename . rfind ( '/' )]): os . makedirs ( interface_filename [: interface_filename . rfind ( '/' )]) file = open ( interface_filename , \"w+\" ) file . write ( interface_file_content ) file . close () rewriter . apply () return True test_ant () target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/input/InputRequest.java\", \"tests/apache-ant/main/org/apache/tools/ant/input/MultipleChoiceInputRequest.java\" ] Source code in refactorings\\extract_interface.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/input/InputRequest.java\", \"tests/apache-ant/main/org/apache/tools/ant/input/MultipleChoiceInputRequest.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if extract_interface ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , [ \"AppChild1\" , \"AppChild2\" ], [ \"printTest()\" ], \"ExtractedInterface\" , \"/home/ali/Desktop/code/TestProject/src/test_package/ExtractedInterface.java\" , # lambda x: \"tests/extract_interface_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"Extract interface"},{"location":"refactorings/extract_interface/#extract-interface","text":"","title":"Extract interface"},{"location":"refactorings/extract_interface/#refactorings.extract_interface--introduction","text":"When multiple clients are using the same part of a class interface, or part of the interface in two classes is the same; Extract Interface Refactoring moves this identical portion to its own interface.","title":"Introduction"},{"location":"refactorings/extract_interface/#refactorings.extract_interface--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/extract_interface/#refactorings.extract_interface--pre-conditions","text":"precondition is whether the package name, all the class names and method names in those classes exist. The parameter types and return types of each method should be the same across the classes.","title":"Pre Conditions:"},{"location":"refactorings/extract_interface/#refactorings.extract_interface--post-conditions","text":"No specific Post Condition","title":"Post Conditions:"},{"location":"refactorings/extract_interface/#refactorings.extract_interface.extract_interface","text":"The main function that does the process of extract interface refactoring. Splits the identical,reused portion of the interface, creates a new interface, and moves the split portion to the new interface. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the classes) required class_names list The classes which are going to implement the new interface required method_keys list The methods which are going to be included in the interface required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D74753160> interface_name str The new interface name required interface_filename str The new interface file name required Returns: Type Description bool No returns Source code in refactorings\\extract_interface.py def extract_interface ( source_filenames : list , package_name : str , class_names : list , method_keys : list , interface_name : str , interface_filename : str , filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of extract interface refactoring. Splits the identical,reused portion of the interface, creates a new interface, and moves the split portion to the new interface. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the classes) class_names (str): The classes which are going to implement the new interface method_keys (str): The methods which are going to be included in the interface filename_mapping (str): Mapping the file's name to the correct format so that it can be processed interface_name (str): The new interface name interface_filename (str): The new interface file name Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) if package_name not in program . packages \\ or any ( class_name not in program . packages [ package_name ] . classes for class_name in class_names ) \\ or any ( method_key not in program . packages [ package_name ] . classes [ class_name ] . methods for class_name in class_names for method_key in method_keys ): return False method_returntypes = {} method_parameters = {} method_names = [] for method_key in method_keys : method_names . append ( method_key [: method_key . find ( '(' )]) rewriter = utils2 . Rewriter ( program , filename_mapping ) for class_name in class_names : c : utils_listener_fast . Class = program . packages [ package_name ] . classes [ class_name ] # Add implements to the class has_superinterface = False if c . parser_context . IMPLEMENTS () is not None : # old: c.parser_context.superinterfaces() t = utils_listener_fast . TokensInfo ( c . parser_context . typeList ()) # old: c.parser_context.superinterfaces() has_superinterface = True elif c . parser_context . EXTENDS () is not None : # old: c.parser_context.superclass() t = utils_listener_fast . TokensInfo ( c . parser_context . typeType ()) # old: c.parser_context.superclass() elif c . parser_context . typeParameters () is not None : t = utils_listener_fast . TokensInfo ( c . parser_context . typeParameters ()) else : # old: TokensInfo(c.parser_context.identifier()) t = utils_listener_fast . TokensInfo ( c . parser_context ) t . stop = c . parser_context . IDENTIFIER () . getSymbol () . tokenIndex rewriter . insert_after ( t , ( \", \" if has_superinterface else \" implements \" ) + interface_name ) for method_key in method_keys : m : utils_listener_fast . Method = c . methods [ method_key ] # Check if the return types / parameter types are the same # Or add to dictionary if method_key in method_returntypes : if method_returntypes [ method_key ] != m . returntype : return False if len ( method_parameters [ method_key ]) != len ( m . parameters ): return False for i in range ( len ( m . parameters )): if method_parameters [ method_key ][ i ][ 0 ] != m . parameters [ i ][ 0 ]: return False else : method_returntypes [ method_key ] = m . returntype method_parameters [ method_key ] = m . parameters # Manage method modifiers if len ( m . modifiers_parser_contexts ) > 0 : t = utils_listener_fast . TokensInfo ( m . modifiers_parser_contexts [ 0 ]) else : t = m . get_tokens_info () rewriter . insert_before_start ( t , # old: m.get_tokens_info() # without requiring t ( \"\" if \"@Override\" in m . modifiers else \"@Override \\n \" ) + ( \"\" if \"public\" in m . modifiers else \"public \" ) ) for i in range ( len ( m . modifiers )): mm = m . modifiers [ i ] if mm == \"private\" or mm == \"protected\" : t = utils_listener_fast . TokensInfo ( m . modifiers_parser_contexts [ i ]) # old: m.parser_context.methodModifier(i) rewriter . replace ( t , \"\" ) # Change variable types to the interface if only interface methods are used. for package_name in program . packages : p : utils_listener_fast . Package = program . packages [ package_name ] for class_name in p . classes : c : utils_listener_fast . Class = p . classes [ class_name ] fields_of_interest = {} for fn in c . fields : f : utils_listener_fast . Field = c . fields [ fn ] d = False for cn in class_names : if ( f . datatype == cn and f . file_info . has_imported_class ( package_name , cn )) \\ or ( package_name is not None and f . datatype == package_name + '.' + cn ): d = True break if d and \"private\" in f . modifiers : fields_of_interest [ f . name ] = f for method_key in c . methods : m : utils_listener_fast . Method = c . methods [ method_key ] vars_of_interest = {} for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . LocalVariable ): for cn in class_names : if ( item . datatype == cn and c . file_info . has_imported_class ( package_name , cn )) \\ or ( package_name is not None and item . datatype == package_name + '.' + cn ): vars_of_interest [ item . identifier ] = item break if isinstance ( item , utils_listener_fast . MethodInvocation ): if len ( item . dot_separated_identifiers ) == 2 or \\ ( len ( item . dot_separated_identifiers ) == 3 and item . dot_separated_identifiers [ 0 ] == \"this\" ): if item . dot_separated_identifiers [ - 2 ] in vars_of_interest : if item . dot_separated_identifiers [ - 1 ] not in method_names : vars_of_interest . pop ( item . dot_separated_identifiers [ - 2 ]) elif item . dot_separated_identifiers [ - 2 ] in fields_of_interest \\ and item . dot_separated_identifiers [ - 1 ] not in method_names : fields_of_interest . pop ( item . dot_separated_identifiers [ - 2 ]) for var_name in vars_of_interest : var = vars_of_interest [ var_name ] if m . file_info . has_imported_package ( package_name ): # old: var.parser_context.unannType() rewriter . replace ( utils_listener_fast . TokensInfo ( var . parser_context . typeType ()), interface_name ) else : if package_name is None : break # old: var.parser_context.unannType() rewriter . replace ( utils_listener_fast . TokensInfo ( var . parser_context . typeType ()), package_name + '.' + interface_name ) for field_name in fields_of_interest : f = fields_of_interest [ field_name ] if c . file_info . has_imported_package ( package_name ): typename = interface_name else : if package_name is None : break typename = package_name + '.' + interface_name if len ( f . neighbor_names ) == 0 : rewriter . replace ( utils_listener_fast . TokensInfo ( f . parser_context . typeType ()), typename ) # old: f.parser_context.unannType() else : if not any ( nn in fields_of_interest for nn in f . neighbor_names ): t = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators ]) if f . index_in_variable_declarators == 0 : t . stop = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators + 1 ]) . start - 1 else : t . start = utils_listener_fast . TokensInfo ( f . all_variable_declarator_contexts [ f . index_in_variable_declarators - 1 ]) . start + 1 rewriter . replace ( t , \"\" ) rewriter . insert_after ( f . get_tokens_info (), \" \\n private \" + typename + \" \" + f . name + ( \" = \" + f . initializer + \";\" if f . initializer is not None else \";\" ) ) # Create the interface interface_file_content = ( \"package \" + package_name + \"; \\n\\n \" + \"public interface \" + interface_name + \" \\n \" + \"{ \\n \" ) for method_key in method_keys : method_name = method_key [: method_key . find ( '(' )] interface_file_content += \" \" + method_returntypes [ method_key ] + \" \" + method_name + \"(\" if len ( method_parameters [ method_key ]) > 0 : interface_file_content += method_parameters [ method_key ][ 0 ][ 0 ] + \" \" + method_parameters [ method_key ][ 0 ][ 1 ] for i in range ( 1 , len ( method_parameters [ method_key ])): param = method_parameters [ method_key ][ i ] interface_file_content += \", \" + param [ 0 ] + \" \" + param [ 1 ] interface_file_content += \"); \\n \" interface_file_content += \"} \\n \" if not os . path . exists ( interface_filename [: interface_filename . rfind ( '/' )]): os . makedirs ( interface_filename [: interface_filename . rfind ( '/' )]) file = open ( interface_filename , \"w+\" ) file . write ( interface_file_content ) file . close () rewriter . apply () return True","title":"extract_interface()"},{"location":"refactorings/extract_interface/#refactorings.extract_interface.test_ant","text":"target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/input/InputRequest.java\", \"tests/apache-ant/main/org/apache/tools/ant/input/MultipleChoiceInputRequest.java\" ] Source code in refactorings\\extract_interface.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/input/InputRequest.java\", \"tests/apache-ant/main/org/apache/tools/ant/input/MultipleChoiceInputRequest.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if extract_interface ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , [ \"AppChild1\" , \"AppChild2\" ], [ \"printTest()\" ], \"ExtractedInterface\" , \"/home/ali/Desktop/code/TestProject/src/test_package/ExtractedInterface.java\" , # lambda x: \"tests/extract_interface_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"test_ant()"},{"location":"refactorings/increase_field_visibility/","text":"Increase field visibility Introduction Increase the visibility of a field from private to package, package to protected or protected to public. Pre and Post Conditions Pre Conditions: User must enter the field's name, and the source class's name for the refactoring in order to increase the target field's visibility. Post Conditions: No specific Post Condition __init__ ( self , common_token_stream = None , source_class = None , field_name = None ) special To implement Increase Field Visibility refactoring based on its actors. Detects the required field and increases/changes its visibility status. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose visibility status has to be changed None Returns: Type Description No returns Source code in refactorings\\increase_field_visibility.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"To implement Increase Field Visibility refactoring based on its actors. Detects the required field and increases/changes its visibility status. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose visibility status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . detected_field = None self . detected_method = None self . TAB = \" \\t \" self . NEW_LINE = \" \\n \" self . code = \"\" self . tempdeclarationcode = \"\"","title":"Increase field visibility"},{"location":"refactorings/increase_field_visibility/#increase-field-visibility","text":"","title":"Increase field visibility"},{"location":"refactorings/increase_field_visibility/#refactorings.increase_field_visibility.IncreaseFieldVisibilityRefactoringListener--introduction","text":"Increase the visibility of a field from private to package, package to protected or protected to public.","title":"Introduction"},{"location":"refactorings/increase_field_visibility/#refactorings.increase_field_visibility.IncreaseFieldVisibilityRefactoringListener--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/increase_field_visibility/#refactorings.increase_field_visibility.IncreaseFieldVisibilityRefactoringListener--pre-conditions","text":"User must enter the field's name, and the source class's name for the refactoring in order to increase the target field's visibility.","title":"Pre Conditions:"},{"location":"refactorings/increase_field_visibility/#refactorings.increase_field_visibility.IncreaseFieldVisibilityRefactoringListener--post-conditions","text":"No specific Post Condition","title":"Post Conditions:"},{"location":"refactorings/increase_field_visibility/#refactorings.increase_field_visibility.IncreaseFieldVisibilityRefactoringListener.__init__","text":"To implement Increase Field Visibility refactoring based on its actors. Detects the required field and increases/changes its visibility status. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose visibility status has to be changed None Returns: Type Description No returns Source code in refactorings\\increase_field_visibility.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"To implement Increase Field Visibility refactoring based on its actors. Detects the required field and increases/changes its visibility status. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose visibility status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . detected_field = None self . detected_method = None self . TAB = \" \\t \" self . NEW_LINE = \" \\n \" self . code = \"\" self . tempdeclarationcode = \"\"","title":"__init__()"},{"location":"refactorings/make_field_final/","text":"Make field final Introduction Add the final property to a field, so that it never changes once it is initialized. Pre and Post Conditions Pre and Post Conditions Pre Conditions: User must enter the field's name and the name of the source class in order to make it final Check if the field exists, then make it final Post Conditions: The value of this field should never be changed in the project __init__ ( self , common_token_stream = None , source_class = None , field_name = None ) special The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and changes its status to final. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose final status has to be changed None Returns: Type Description No returns Source code in refactorings\\make_field_final.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and changes its status to final. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose final status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . is_final = False","title":"Make field final"},{"location":"refactorings/make_field_final/#make-field-final","text":"","title":"Make field final"},{"location":"refactorings/make_field_final/#refactorings.make_field_final.MakeFieldFinalRefactoringListener--introduction","text":"Add the final property to a field, so that it never changes once it is initialized. Pre and Post Conditions","title":"Introduction"},{"location":"refactorings/make_field_final/#refactorings.make_field_final.MakeFieldFinalRefactoringListener--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/make_field_final/#refactorings.make_field_final.MakeFieldFinalRefactoringListener--pre-conditions","text":"User must enter the field's name and the name of the source class in order to make it final Check if the field exists, then make it final","title":"Pre Conditions:"},{"location":"refactorings/make_field_final/#refactorings.make_field_final.MakeFieldFinalRefactoringListener--post-conditions","text":"The value of this field should never be changed in the project","title":"Post Conditions:"},{"location":"refactorings/make_field_final/#refactorings.make_field_final.MakeFieldFinalRefactoringListener.__init__","text":"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and changes its status to final. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose final status has to be changed None Returns: Type Description No returns Source code in refactorings\\make_field_final.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and changes its status to final. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str): Name of the field whose final status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . is_final = False","title":"__init__()"},{"location":"refactorings/make_field_non_final/","text":"Make field non-final Introduction Remove the \"final\" property from a field, so that it can be changed after initialization. Pre and Post Conditions Pre Conditions: User must enter the field's name and the name of the source class in order to make it non-final Check if the field exists, then make it non-final Post Conditions: No specific Post Condition __init__ ( self , common_token_stream = None , source_class = None , field_name = None ) special The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and removes the \"final\" keyword from its properties. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose final status has to be changed None !!! returns No returns Source code in refactorings\\make_field_non_final.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and removes the \"final\" keyword from its properties. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str):Name of the field whose final status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . is_final = False","title":"Make field non-final"},{"location":"refactorings/make_field_non_final/#make-field-non-final","text":"","title":"Make field non-final"},{"location":"refactorings/make_field_non_final/#refactorings.make_field_non_final.MakeFieldNonFinalRefactoringListener--introduction","text":"Remove the \"final\" property from a field, so that it can be changed after initialization.","title":"Introduction"},{"location":"refactorings/make_field_non_final/#refactorings.make_field_non_final.MakeFieldNonFinalRefactoringListener--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/make_field_non_final/#refactorings.make_field_non_final.MakeFieldNonFinalRefactoringListener--pre-conditions","text":"User must enter the field's name and the name of the source class in order to make it non-final Check if the field exists, then make it non-final","title":"Pre Conditions:"},{"location":"refactorings/make_field_non_final/#refactorings.make_field_non_final.MakeFieldNonFinalRefactoringListener--post-conditions","text":"No specific Post Condition","title":"Post Conditions:"},{"location":"refactorings/make_field_non_final/#refactorings.make_field_non_final.MakeFieldNonFinalRefactoringListener.__init__","text":"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and removes the \"final\" keyword from its properties. Parameters: Name Type Description Default common_token_stream CommonTokenStream A stream of tokens generated by parsing the main file using the ANTLR parser generator None source_class str Name of the class in which the refactoring has to be done None field_name str Name of the field whose final status has to be changed None !!! returns No returns Source code in refactorings\\make_field_non_final.py def __init__ ( self , common_token_stream : CommonTokenStream = None , source_class = None , field_name : str = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods. Detects the desired field and removes the \"final\" keyword from its properties. Args: common_token_stream (CommonTokenStream): A stream of tokens generated by parsing the main file using the ANTLR parser generator source_class (str): Name of the class in which the refactoring has to be done field_name (str):Name of the field whose final status has to be changed Returns: No returns \"\"\" if field_name is None : self . field_name = \"\" else : self . field_name = field_name if source_class is None : self . source_class = \"\" else : self . source_class = source_class if common_token_stream is None : raise ValueError ( 'common_token_stream is None' ) else : self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . is_source_class = False self . is_final = False","title":"__init__()"},{"location":"refactorings/pull_up_field/","text":"Pull-up field Introduction When subclasses grow and get developed separately, identical (or nearly identical) fields and methods appear. Pull up field refactoring removes the repetitive field from subclasses and moves it to a superclass. Pre and Post Conditions Pre Conditions: There should exist a corresponding child and parent in the project. The field that should be pulled up must be valid. The user must enter the package's name, class's name and the fields that need to be removed. Post Conditions: The changed field's usages and callings will also change respectively. There will be children and parents having their desired fields added or removed. pullup_field ( source_filenames , package_name , class_name , field_name , filename_mapping =< function < lambda > at 0x0000015D7484B0D0 > ) The main function that does the process of pull up field refactoring. Removes the repetitive fields from the subclasses, creates the superclass, and moves the fields to the superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the classes/superclasses) required class_name str Name of the class that the field is pulled up from required field_name str Name of the field that has to be refactored required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D7484B0D0> Returns: Type Description bool No returns Source code in refactorings\\pullup_field.py def pullup_field ( source_filenames : list , package_name : str , class_name : str , field_name : str , filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of pull up field refactoring. Removes the repetitive fields from the subclasses, creates the superclass, and moves the fields to the superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the classes/superclasses) class_name (str): Name of the class that the field is pulled up from field_name (str): Name of the field that has to be refactored filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) print ( program . packages ) if package_name not in program . packages \\ or class_name not in program . packages [ package_name ] . classes \\ or field_name not in program . packages [ package_name ] . classes [ class_name ] . fields : return False _class : utils_listener_fast . Class = program . packages [ package_name ] . classes [ class_name ] if _class . superclass_name is None : return False superclass_name = _class . superclass_name superclass : utils_listener_fast . Class = program . packages [ package_name ] . classes [ superclass_name ] superclass_body_start = utils_listener_fast . TokensInfo ( superclass . parser_context . classBody ()) superclass_body_start . stop = superclass_body_start . start # Start and stop both point to the '{' if field_name in superclass . fields : return False datatype = _class . fields [ field_name ] . datatype fields_to_remove = [] for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] if (( c . superclass_name == superclass_name and c . file_info . has_imported_class ( package_name , superclass_name )) \\ or ( package_name is not None and c . superclass_name == package_name + '.' + superclass_name )) \\ and field_name in c . fields \\ and c . fields [ field_name ] . datatype == datatype : fields_to_remove . append ( c . fields [ field_name ]) if len ( fields_to_remove ) == 0 : return False is_public = False is_protected = True for field in fields_to_remove : field : utils_listener_fast . Field = field is_public = is_public or \"public\" in field . modifiers is_protected = is_protected and ( \"protected\" in field . modifiers or \"private\" in field . modifiers ) rewriter = utils2 . Rewriter ( program , filename_mapping ) rewriter . insert_after ( superclass_body_start , \" \\n \" + ( \"public \" if is_public else ( \"protected \" if is_protected else \"\" )) + datatype + \" \" + field_name + \";\" ) for field in fields_to_remove : if len ( field . neighbor_names ) == 0 : rewriter . replace ( field . get_tokens_info (), \"\" ) # Have to remove the modifiers too, because of the new grammar. for mod_ctx in field . modifiers_parser_contexts : rewriter . replace ( utils_listener_fast . TokensInfo ( mod_ctx ), \"\" ) else : i = field . index_in_variable_declarators var_ctxs = field . all_variable_declarator_contexts if i == 0 : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . stop = utils_listener_fast . TokensInfo ( var_ctxs [ i + 1 ]) . start - 1 # Include the ',' after it rewriter . replace ( to_remove , \"\" ) else : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . start = utils_listener_fast . TokensInfo ( var_ctxs [ i - 1 ]) . stop + 1 # Include the ',' before it rewriter . replace ( to_remove , \"\" ) # Add initializer to class constructor if initializer exists in field declaration if field . initializer is not None : _class : utils_listener_fast . Class = program . packages [ field . package_name ] . classes [ field . class_name ] initializer_statement = ( field . name + \" = \" + ( \"new \" + field . datatype + \" \" if field . initializer . startswith ( '{' ) else \"\" ) + field . initializer + \";\" ) has_contructor = False for class_body_decl in _class . parser_context . classBody () . getChildren (): if class_body_decl . getText () in [ '{' , '}' ]: continue member_decl = class_body_decl . memberDeclaration () if member_decl is not None : constructor = member_decl . constructorDeclaration () if constructor is not None : body = constructor . constructorBody # Start token = '{' body_start = utils_listener_fast . TokensInfo ( body ) body_start . stop = body_start . start # Start and stop both point to the '{' rewriter . insert_after ( body_start , \" \\n \" + initializer_statement ) has_contructor = True if not has_contructor : body = _class . parser_context . classBody () body_start = utils_listener_fast . TokensInfo ( body ) body_start . stop = body_start . start # Start and stop both point to the '{' rewriter . insert_after ( body_start , \" \\n \" + _class . name + \"() { \" + initializer_statement + \" }\" ) rewriter . apply () return True test_ant () target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] Source code in refactorings\\pullup_field.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if pullup_field ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , \"AppChild1\" , \"TEST\" , # lambda x: \"tests/pullup_field_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"Pull-up field"},{"location":"refactorings/pull_up_field/#pull-up-field","text":"","title":"Pull-up field"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field--introduction","text":"When subclasses grow and get developed separately, identical (or nearly identical) fields and methods appear. Pull up field refactoring removes the repetitive field from subclasses and moves it to a superclass.","title":"Introduction"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field--pre-conditions","text":"There should exist a corresponding child and parent in the project. The field that should be pulled up must be valid. The user must enter the package's name, class's name and the fields that need to be removed.","title":"Pre Conditions:"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field--post-conditions","text":"The changed field's usages and callings will also change respectively. There will be children and parents having their desired fields added or removed.","title":"Post Conditions:"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field.pullup_field","text":"The main function that does the process of pull up field refactoring. Removes the repetitive fields from the subclasses, creates the superclass, and moves the fields to the superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the classes/superclasses) required class_name str Name of the class that the field is pulled up from required field_name str Name of the field that has to be refactored required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D7484B0D0> Returns: Type Description bool No returns Source code in refactorings\\pullup_field.py def pullup_field ( source_filenames : list , package_name : str , class_name : str , field_name : str , filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of pull up field refactoring. Removes the repetitive fields from the subclasses, creates the superclass, and moves the fields to the superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the classes/superclasses) class_name (str): Name of the class that the field is pulled up from field_name (str): Name of the field that has to be refactored filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) print ( program . packages ) if package_name not in program . packages \\ or class_name not in program . packages [ package_name ] . classes \\ or field_name not in program . packages [ package_name ] . classes [ class_name ] . fields : return False _class : utils_listener_fast . Class = program . packages [ package_name ] . classes [ class_name ] if _class . superclass_name is None : return False superclass_name = _class . superclass_name superclass : utils_listener_fast . Class = program . packages [ package_name ] . classes [ superclass_name ] superclass_body_start = utils_listener_fast . TokensInfo ( superclass . parser_context . classBody ()) superclass_body_start . stop = superclass_body_start . start # Start and stop both point to the '{' if field_name in superclass . fields : return False datatype = _class . fields [ field_name ] . datatype fields_to_remove = [] for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] if (( c . superclass_name == superclass_name and c . file_info . has_imported_class ( package_name , superclass_name )) \\ or ( package_name is not None and c . superclass_name == package_name + '.' + superclass_name )) \\ and field_name in c . fields \\ and c . fields [ field_name ] . datatype == datatype : fields_to_remove . append ( c . fields [ field_name ]) if len ( fields_to_remove ) == 0 : return False is_public = False is_protected = True for field in fields_to_remove : field : utils_listener_fast . Field = field is_public = is_public or \"public\" in field . modifiers is_protected = is_protected and ( \"protected\" in field . modifiers or \"private\" in field . modifiers ) rewriter = utils2 . Rewriter ( program , filename_mapping ) rewriter . insert_after ( superclass_body_start , \" \\n \" + ( \"public \" if is_public else ( \"protected \" if is_protected else \"\" )) + datatype + \" \" + field_name + \";\" ) for field in fields_to_remove : if len ( field . neighbor_names ) == 0 : rewriter . replace ( field . get_tokens_info (), \"\" ) # Have to remove the modifiers too, because of the new grammar. for mod_ctx in field . modifiers_parser_contexts : rewriter . replace ( utils_listener_fast . TokensInfo ( mod_ctx ), \"\" ) else : i = field . index_in_variable_declarators var_ctxs = field . all_variable_declarator_contexts if i == 0 : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . stop = utils_listener_fast . TokensInfo ( var_ctxs [ i + 1 ]) . start - 1 # Include the ',' after it rewriter . replace ( to_remove , \"\" ) else : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . start = utils_listener_fast . TokensInfo ( var_ctxs [ i - 1 ]) . stop + 1 # Include the ',' before it rewriter . replace ( to_remove , \"\" ) # Add initializer to class constructor if initializer exists in field declaration if field . initializer is not None : _class : utils_listener_fast . Class = program . packages [ field . package_name ] . classes [ field . class_name ] initializer_statement = ( field . name + \" = \" + ( \"new \" + field . datatype + \" \" if field . initializer . startswith ( '{' ) else \"\" ) + field . initializer + \";\" ) has_contructor = False for class_body_decl in _class . parser_context . classBody () . getChildren (): if class_body_decl . getText () in [ '{' , '}' ]: continue member_decl = class_body_decl . memberDeclaration () if member_decl is not None : constructor = member_decl . constructorDeclaration () if constructor is not None : body = constructor . constructorBody # Start token = '{' body_start = utils_listener_fast . TokensInfo ( body ) body_start . stop = body_start . start # Start and stop both point to the '{' rewriter . insert_after ( body_start , \" \\n \" + initializer_statement ) has_contructor = True if not has_contructor : body = _class . parser_context . classBody () body_start = utils_listener_fast . TokensInfo ( body ) body_start . stop = body_start . start # Start and stop both point to the '{' rewriter . insert_after ( body_start , \" \\n \" + _class . name + \"() { \" + initializer_statement + \" }\" ) rewriter . apply () return True","title":"pullup_field()"},{"location":"refactorings/pull_up_field/#refactorings.pullup_field.test_ant","text":"target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] Source code in refactorings\\pullup_field.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if pullup_field ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , \"AppChild1\" , \"TEST\" , # lambda x: \"tests/pullup_field_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"test_ant()"},{"location":"refactorings/pull_up_method/","text":"Pull-up method Introduction When subclasses grow and get developed separately, your code may have methods that perform similar work. Pull up method refactoring removes the repetitive method from subclasses and moves it to a superclass. Pre and Post Conditions Pre Conditions: The source package, class and method should exist. If the method uses attributes and methods that are defined in the body of the classes, The refactoring should not be implemented. Post Conditions: No specific Post Condition pullup_method_refactoring ( source_filenames , package_name , class_name , method_key , filename_mapping =< function < lambda > at 0x0000015D7484B8B0 > ) The main function that does the process of pull up method refactoring. Removes the necessary methods from the subclasses and moves them to a superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done(contains the classes) required class_name str Name of the class in which the refactoring has to be done (pulling up the field from here) required method_key str Name of the method which needs to be removed from the subclasses/pulled up required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D7484B8B0> Returns: Type Description No returns Source code in refactorings\\pullup_method.py def pullup_method_refactoring ( source_filenames : list , package_name : str , class_name : str , method_key : str , filename_mapping = lambda x : x ): \"\"\"The main function that does the process of pull up method refactoring. Removes the necessary methods from the subclasses and moves them to a superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done(contains the classes) class_name (str): Name of the class in which the refactoring has to be done (pulling up the field from here) method_key (str): Name of the method which needs to be removed from the subclasses/pulled up filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = get_program ( source_filenames ) # getting the program packages _sourceclass = program . packages [ package_name ] . classes [ class_name ] target_class_name = _sourceclass . superclass_name static = 0 removemethod = get_removemethods ( program , package_name , target_class_name , method_key , class_name ) # Similar methods in other classes _targetclass = program . packages [ package_name ] . classes [ target_class_name ] _method_name = program . packages [ package_name ] . classes [ class_name ] . methods [ method_key ] tokens_info = TokensInfo ( _method_name . parser_context ) exps = tokens_info . get_token_index ( tokens_info . token_stream . tokens , tokens_info . start , tokens_info . stop ) # list of class variables that are used in the method if _method_name . is_constructor : return False # if method use param of class body return false for token in exps : if token . text in _sourceclass . fields : return False if bool ( _method_name . body_method_invocations_without_typename ) == True : return False Rewriter_ = Rewriter ( program , filename_mapping ) for remove in removemethod : _methodd = removemethod [ remove ] if _methodd != None : _methodds = _methodd [ 0 ] _method = program . packages [ package_name ] . classes [ remove ] . methods [ str ( _methodds )] _method_token_info = TokensInfo ( _method . parser_context ) Rewriter_ . replace ( _method_token_info , \" \" ) class_tokens_info = TokensInfo ( _targetclass . parser_context ) singlefileelement = SingleFileElement ( _method_name . parser_context , _method_name . filename ) token_stream_rewriter = TokenStreamRewriter ( singlefileelement . get_token_stream ()) strofmethod = token_stream_rewriter . getText ( program_name = token_stream_rewriter . DEFAULT_PROGRAM_NAME , start = tokens_info . start , stop = tokens_info . stop ) Rewriter_ . insert_before ( tokens_info = class_tokens_info , text = strofmethod ) Rewriter_ . apply () # The Method has to be updated anywhere else that it's used for package_names in program . packages : package = program . packages [ package_names ] for class_ in package . classes : _class = package . classes [ class_ ] for method_ in _class . methods : __method = _class . methods [ method_ ] for inv in __method . body_method_invocations : invc = __method . body_method_invocations [ inv ] method_name = method_key [: method_key . find ( '(' )] if ( invc [ 0 ] == method_name & package_names == package_name ): inv_tokens_info = TokensInfo ( inv ) if ( static == 0 ): class_token_info = TokensInfo ( _class . body_context ) Rewriter_ . insert_after_start ( class_token_info , target_class_name + \" \" + str . lower ( target_class_name ) + \"=\" + \"new \" + target_class_name + \"();\" ) Rewriter_ . apply () Rewriter_ . replace ( inv_tokens_info , target_class_name ) Rewriter_ . apply () return True","title":"Pull-up method"},{"location":"refactorings/pull_up_method/#pull-up-method","text":"","title":"Pull-up method"},{"location":"refactorings/pull_up_method/#refactorings.pullup_method--introduction","text":"When subclasses grow and get developed separately, your code may have methods that perform similar work. Pull up method refactoring removes the repetitive method from subclasses and moves it to a superclass.","title":"Introduction"},{"location":"refactorings/pull_up_method/#refactorings.pullup_method--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/pull_up_method/#refactorings.pullup_method--pre-conditions","text":"The source package, class and method should exist. If the method uses attributes and methods that are defined in the body of the classes, The refactoring should not be implemented.","title":"Pre Conditions:"},{"location":"refactorings/pull_up_method/#refactorings.pullup_method--post-conditions","text":"No specific Post Condition","title":"Post Conditions:"},{"location":"refactorings/pull_up_method/#refactorings.pullup_method.pullup_method_refactoring","text":"The main function that does the process of pull up method refactoring. Removes the necessary methods from the subclasses and moves them to a superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done(contains the classes) required class_name str Name of the class in which the refactoring has to be done (pulling up the field from here) required method_key str Name of the method which needs to be removed from the subclasses/pulled up required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D7484B8B0> Returns: Type Description No returns Source code in refactorings\\pullup_method.py def pullup_method_refactoring ( source_filenames : list , package_name : str , class_name : str , method_key : str , filename_mapping = lambda x : x ): \"\"\"The main function that does the process of pull up method refactoring. Removes the necessary methods from the subclasses and moves them to a superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done(contains the classes) class_name (str): Name of the class in which the refactoring has to be done (pulling up the field from here) method_key (str): Name of the method which needs to be removed from the subclasses/pulled up filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = get_program ( source_filenames ) # getting the program packages _sourceclass = program . packages [ package_name ] . classes [ class_name ] target_class_name = _sourceclass . superclass_name static = 0 removemethod = get_removemethods ( program , package_name , target_class_name , method_key , class_name ) # Similar methods in other classes _targetclass = program . packages [ package_name ] . classes [ target_class_name ] _method_name = program . packages [ package_name ] . classes [ class_name ] . methods [ method_key ] tokens_info = TokensInfo ( _method_name . parser_context ) exps = tokens_info . get_token_index ( tokens_info . token_stream . tokens , tokens_info . start , tokens_info . stop ) # list of class variables that are used in the method if _method_name . is_constructor : return False # if method use param of class body return false for token in exps : if token . text in _sourceclass . fields : return False if bool ( _method_name . body_method_invocations_without_typename ) == True : return False Rewriter_ = Rewriter ( program , filename_mapping ) for remove in removemethod : _methodd = removemethod [ remove ] if _methodd != None : _methodds = _methodd [ 0 ] _method = program . packages [ package_name ] . classes [ remove ] . methods [ str ( _methodds )] _method_token_info = TokensInfo ( _method . parser_context ) Rewriter_ . replace ( _method_token_info , \" \" ) class_tokens_info = TokensInfo ( _targetclass . parser_context ) singlefileelement = SingleFileElement ( _method_name . parser_context , _method_name . filename ) token_stream_rewriter = TokenStreamRewriter ( singlefileelement . get_token_stream ()) strofmethod = token_stream_rewriter . getText ( program_name = token_stream_rewriter . DEFAULT_PROGRAM_NAME , start = tokens_info . start , stop = tokens_info . stop ) Rewriter_ . insert_before ( tokens_info = class_tokens_info , text = strofmethod ) Rewriter_ . apply () # The Method has to be updated anywhere else that it's used for package_names in program . packages : package = program . packages [ package_names ] for class_ in package . classes : _class = package . classes [ class_ ] for method_ in _class . methods : __method = _class . methods [ method_ ] for inv in __method . body_method_invocations : invc = __method . body_method_invocations [ inv ] method_name = method_key [: method_key . find ( '(' )] if ( invc [ 0 ] == method_name & package_names == package_name ): inv_tokens_info = TokensInfo ( inv ) if ( static == 0 ): class_token_info = TokensInfo ( _class . body_context ) Rewriter_ . insert_after_start ( class_token_info , target_class_name + \" \" + str . lower ( target_class_name ) + \"=\" + \"new \" + target_class_name + \"();\" ) Rewriter_ . apply () Rewriter_ . replace ( inv_tokens_info , target_class_name ) Rewriter_ . apply () return True","title":"pullup_method_refactoring()"},{"location":"refactorings/push_down_field/","text":"Push down field Introduction Although it was planned to use a field universally for all classes, in reality the field is used only in some subclasses. This situation can occur when planned features fail to pan out, for example. because of this, we push down the field from the superclass into its related subclass. Pre and Post Conditions Pre Conditions: There should exist a corresponding child and parent in the project. The field that should be pushed down must be valid. The user must enter the package's name, class's name and the fields that need to be added. Post Conditions: The changed field's usages and callings will also change respectively. There will be children and parents having their desired fields added or removed. pushdown_field ( source_filenames , package_name , superclass_name , field_name , class_names = [], filename_mapping =< function < lambda > at 0x0000015D74856280 > ) The main function that does the process of pull up field refactoring. Adds the necessary fields to the subclasses and removes them from the superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the superclass) required superclass_name str The name of the needed superclass required class_names list Name of the classes in which the refactoring has to be done (the classes to push down field from) [] field_name str Name of the field that has to be refactored required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D74856280> Returns: Type Description bool No returns Source code in refactorings\\pushdown_field.py def pushdown_field ( source_filenames : list , package_name : str , superclass_name : str , field_name : str , class_names : list = [], filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of pull up field refactoring. Adds the necessary fields to the subclasses and removes them from the superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the superclass) superclass_name (str): The name of the needed superclass class_names (str): Name of the classes in which the refactoring has to be done (the classes to push down field from) field_name (str): Name of the field that has to be refactored filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) if package_name not in program . packages \\ or superclass_name not in program . packages [ package_name ] . classes \\ or field_name not in program . packages [ package_name ] . classes [ superclass_name ] . fields : return False superclass : utils_listener_fast . Class = program . packages [ package_name ] . classes [ superclass_name ] for mk in superclass . methods : m : utils_listener_fast . Method = superclass . methods [ mk ] for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . ExpressionName ): if (( len ( item . dot_separated_identifiers ) == 1 and item . dot_separated_identifiers [ 0 ] == field_name ) or ( len ( item . dot_separated_identifiers ) == 2 and item . dot_separated_identifiers [ 0 ] == \"this\" and item . dot_separated_identifiers [ 1 ] == field_name )): return False # all_derived_classes = [] # Not needed other_derived_classes = [] classes_to_add_to = [] for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] if (( c . superclass_name == superclass_name and c . file_info . has_imported_class ( package_name , superclass_name )) \\ or ( package_name is not None and c . superclass_name == package_name + '.' + superclass_name )): # all_derived_classes.append(c) if len ( class_names ) == 0 or cn in class_names : if field_name in c . fields : return False else : classes_to_add_to . append ( c ) else : other_derived_classes . append ( c ) # Check if the field is used from the superclass or other derived classes for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] has_imported_superclass = c . file_info . has_imported_class ( package_name , superclass_name ) fields_of_superclass_type_or_others = [] for fn in c . fields : f : utils_listener_fast . Field = c . fields [ fn ] if ( f . datatype == superclass_name and has_imported_superclass ) \\ or ( package_name is not None and f . datatype == ( package_name + '.' + superclass_name )): fields_of_superclass_type_or_others . append ( f . name ) if any (( c . file_info . has_imported_class ( o . package_name , o . name ) and f . datatype == o . name ) or f . datatype == ( o . package_name + '.' + o . name ) for o in other_derived_classes ): fields_of_superclass_type_or_others . append ( f . name ) for mk in c . methods : m : utils_listener_fast . Method = c . methods [ mk ] local_vars_of_superclass_type_or_others = [] for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . LocalVariable ): if ( item . datatype == superclass_name and has_imported_superclass ) \\ or item . datatype == ( package_name + '.' + superclass_name ): local_vars_of_superclass_type_or_others . append ( item . identifier ) if any (( c . file_info . has_imported_class ( o . package_name , o . name ) and item . datatype == o . name ) or item . datatype == ( o . package_name + '.' + o . name ) for o in other_derived_classes ): local_vars_of_superclass_type_or_others . append ( item . identifier ) elif isinstance ( item , utils_listener_fast . ExpressionName ): if item . dot_separated_identifiers [ - 1 ] == field_name \\ and ( ( len ( item . dot_separated_identifiers ) == 2 ) or ( len ( item . dot_separated_identifiers ) == 3 and item . dot_separated_identifiers [ 0 ] == \"this\" ) ) and ( ( item . dot_separated_identifiers [ - 2 ] in local_vars_of_superclass_type_or_others and len ( item . dot_separated_identifiers ) == 2 ) or item . dot_separated_identifiers [ - 2 ] in fields_of_superclass_type_or_others ): return False rewriter = utils2 . Rewriter ( program , filename_mapping ) field = superclass . fields [ field_name ] if len ( field . neighbor_names ) == 0 : rewriter . replace ( field . get_tokens_info (), \"\" ) # Have to remove the modifiers too, because of the new grammar. for mod_ctx in field . modifiers_parser_contexts : rewriter . replace ( utils_listener_fast . TokensInfo ( mod_ctx ), \"\" ) else : i = field . index_in_variable_declarators var_ctxs = field . all_variable_declarator_contexts if i == 0 : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . stop = utils_listener_fast . TokensInfo ( var_ctxs [ i + 1 ]) . start - 1 # Include the ',' after it rewriter . replace ( to_remove , \"\" ) else : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . start = utils_listener_fast . TokensInfo ( var_ctxs [ i - 1 ]) . stop + 1 # Include the ',' before it rewriter . replace ( to_remove , \"\" ) is_public = \"public\" in field . modifiers is_protected = \"protected\" in field . modifiers modifier = ( \"public \" if is_public else ( \"protected \" if is_protected else \"\" )) for c in classes_to_add_to : c_body_start = utils_listener_fast . TokensInfo ( c . parser_context . classBody ()) c_body_start . stop = c_body_start . start # Start and stop both point to the '{' rewriter . insert_after ( c_body_start , \" \\n \" + modifier + field . datatype + \" \" + field_name \\ + (( \" = \" + field . initializer ) if field . initializer is not None else \"\" ) + \";\" ) rewriter . apply () return True test_ant () target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] Source code in refactorings\\pushdown_field.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if pushdown_field ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , \"App\" , \"push_down\" , [], # lambda x: \"tests/pushdown_field_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"Push-down field"},{"location":"refactorings/push_down_field/#push-down-field","text":"","title":"Push down field"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field--introduction","text":"Although it was planned to use a field universally for all classes, in reality the field is used only in some subclasses. This situation can occur when planned features fail to pan out, for example. because of this, we push down the field from the superclass into its related subclass.","title":"Introduction"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field--pre-conditions","text":"There should exist a corresponding child and parent in the project. The field that should be pushed down must be valid. The user must enter the package's name, class's name and the fields that need to be added.","title":"Pre Conditions:"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field--post-conditions","text":"The changed field's usages and callings will also change respectively. There will be children and parents having their desired fields added or removed.","title":"Post Conditions:"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field.pushdown_field","text":"The main function that does the process of pull up field refactoring. Adds the necessary fields to the subclasses and removes them from the superclass. Parameters: Name Type Description Default source_filenames list A list of file names to be processed required package_name str The name of the package in which the refactoring has to be done (contains the superclass) required superclass_name str The name of the needed superclass required class_names list Name of the classes in which the refactoring has to be done (the classes to push down field from) [] field_name str Name of the field that has to be refactored required filename_mapping str Mapping the file's name to the correct format so that it can be processed <function <lambda> at 0x0000015D74856280> Returns: Type Description bool No returns Source code in refactorings\\pushdown_field.py def pushdown_field ( source_filenames : list , package_name : str , superclass_name : str , field_name : str , class_names : list = [], filename_mapping = lambda x : ( x [: - 5 ] if x . endswith ( \".java\" ) else x ) + \".java\" ) -> bool : \"\"\"The main function that does the process of pull up field refactoring. Adds the necessary fields to the subclasses and removes them from the superclass. Args: source_filenames (list): A list of file names to be processed package_name (str): The name of the package in which the refactoring has to be done (contains the superclass) superclass_name (str): The name of the needed superclass class_names (str): Name of the classes in which the refactoring has to be done (the classes to push down field from) field_name (str): Name of the field that has to be refactored filename_mapping (str): Mapping the file's name to the correct format so that it can be processed Returns: No returns \"\"\" program = utils2 . get_program ( source_filenames , print_status = True ) if package_name not in program . packages \\ or superclass_name not in program . packages [ package_name ] . classes \\ or field_name not in program . packages [ package_name ] . classes [ superclass_name ] . fields : return False superclass : utils_listener_fast . Class = program . packages [ package_name ] . classes [ superclass_name ] for mk in superclass . methods : m : utils_listener_fast . Method = superclass . methods [ mk ] for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . ExpressionName ): if (( len ( item . dot_separated_identifiers ) == 1 and item . dot_separated_identifiers [ 0 ] == field_name ) or ( len ( item . dot_separated_identifiers ) == 2 and item . dot_separated_identifiers [ 0 ] == \"this\" and item . dot_separated_identifiers [ 1 ] == field_name )): return False # all_derived_classes = [] # Not needed other_derived_classes = [] classes_to_add_to = [] for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] if (( c . superclass_name == superclass_name and c . file_info . has_imported_class ( package_name , superclass_name )) \\ or ( package_name is not None and c . superclass_name == package_name + '.' + superclass_name )): # all_derived_classes.append(c) if len ( class_names ) == 0 or cn in class_names : if field_name in c . fields : return False else : classes_to_add_to . append ( c ) else : other_derived_classes . append ( c ) # Check if the field is used from the superclass or other derived classes for pn in program . packages : p : utils_listener_fast . Package = program . packages [ pn ] for cn in p . classes : c : utils_listener_fast . Class = p . classes [ cn ] has_imported_superclass = c . file_info . has_imported_class ( package_name , superclass_name ) fields_of_superclass_type_or_others = [] for fn in c . fields : f : utils_listener_fast . Field = c . fields [ fn ] if ( f . datatype == superclass_name and has_imported_superclass ) \\ or ( package_name is not None and f . datatype == ( package_name + '.' + superclass_name )): fields_of_superclass_type_or_others . append ( f . name ) if any (( c . file_info . has_imported_class ( o . package_name , o . name ) and f . datatype == o . name ) or f . datatype == ( o . package_name + '.' + o . name ) for o in other_derived_classes ): fields_of_superclass_type_or_others . append ( f . name ) for mk in c . methods : m : utils_listener_fast . Method = c . methods [ mk ] local_vars_of_superclass_type_or_others = [] for item in m . body_local_vars_and_expr_names : if isinstance ( item , utils_listener_fast . LocalVariable ): if ( item . datatype == superclass_name and has_imported_superclass ) \\ or item . datatype == ( package_name + '.' + superclass_name ): local_vars_of_superclass_type_or_others . append ( item . identifier ) if any (( c . file_info . has_imported_class ( o . package_name , o . name ) and item . datatype == o . name ) or item . datatype == ( o . package_name + '.' + o . name ) for o in other_derived_classes ): local_vars_of_superclass_type_or_others . append ( item . identifier ) elif isinstance ( item , utils_listener_fast . ExpressionName ): if item . dot_separated_identifiers [ - 1 ] == field_name \\ and ( ( len ( item . dot_separated_identifiers ) == 2 ) or ( len ( item . dot_separated_identifiers ) == 3 and item . dot_separated_identifiers [ 0 ] == \"this\" ) ) and ( ( item . dot_separated_identifiers [ - 2 ] in local_vars_of_superclass_type_or_others and len ( item . dot_separated_identifiers ) == 2 ) or item . dot_separated_identifiers [ - 2 ] in fields_of_superclass_type_or_others ): return False rewriter = utils2 . Rewriter ( program , filename_mapping ) field = superclass . fields [ field_name ] if len ( field . neighbor_names ) == 0 : rewriter . replace ( field . get_tokens_info (), \"\" ) # Have to remove the modifiers too, because of the new grammar. for mod_ctx in field . modifiers_parser_contexts : rewriter . replace ( utils_listener_fast . TokensInfo ( mod_ctx ), \"\" ) else : i = field . index_in_variable_declarators var_ctxs = field . all_variable_declarator_contexts if i == 0 : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . stop = utils_listener_fast . TokensInfo ( var_ctxs [ i + 1 ]) . start - 1 # Include the ',' after it rewriter . replace ( to_remove , \"\" ) else : to_remove = utils_listener_fast . TokensInfo ( var_ctxs [ i ]) to_remove . start = utils_listener_fast . TokensInfo ( var_ctxs [ i - 1 ]) . stop + 1 # Include the ',' before it rewriter . replace ( to_remove , \"\" ) is_public = \"public\" in field . modifiers is_protected = \"protected\" in field . modifiers modifier = ( \"public \" if is_public else ( \"protected \" if is_protected else \"\" )) for c in classes_to_add_to : c_body_start = utils_listener_fast . TokensInfo ( c . parser_context . classBody ()) c_body_start . stop = c_body_start . start # Start and stop both point to the '{' rewriter . insert_after ( c_body_start , \" \\n \" + modifier + field . datatype + \" \" + field_name \\ + (( \" = \" + field . initializer ) if field . initializer is not None else \"\" ) + \";\" ) rewriter . apply () return True","title":"pushdown_field()"},{"location":"refactorings/push_down_field/#refactorings.pushdown_field.test_ant","text":"target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] Source code in refactorings\\pushdown_field.py def test_ant (): \"\"\" target_files = [ \"tests/apache-ant/main/org/apache/tools/ant/types/ArchiveFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/TarFileSet.java\", \"tests/apache-ant/main/org/apache/tools/ant/types/ZipFileSet.java\" ] \"\"\" ant_dir = \"/home/ali/Desktop/code/TestProject/\" print ( \"Success!\" if pushdown_field ( utils2 . get_filenames_in_dir ( ant_dir ), \"test_package\" , \"App\" , \"push_down\" , [], # lambda x: \"tests/pushdown_field_ant/\" + x[len(ant_dir):] ) else \"Cannot refactor.\" )","title":"test_ant()"},{"location":"refactorings/rename_method/","text":"Rename method Introduction When the name of a method does not explain what the method does (method's functionality), it needs to be changed. Pre and Post Conditions Pre Conditions: User must enter the existing method's name, The source class's name for the refactoring, and the new method name in order to rename. Check if the method exist, then rename it. Post Conditions: After refactoring, all the old method names in the project should be changed. See whether the method is defined in a superclass or subclass. If so, you must repeat all steps in these classes too. The next method is important for maintaining the functionality of the program during the refactoring process. Create a new method with a new name. Copy the code of the old method to it. Delete all the code in the old method and, instead of it, insert a call for the new method. Find all references to the old method and replace them with references to the new one. Delete the old method. If the old method is part of a public interface, don\u2019t perform this step. Instead, mark the old method as deprecated. __init__ ( self , java_file_path , common_token_stream , scope_class_name , target_method_name , new_name , reference = None ) special The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods Parameters: Name Type Description Default java_file_path(str) Address path to the test/source file required scope_class_name(str) Name of the class in which the refactoring has to be done required target_method_name(str) Name of the method in which the refactoring has to be done required new_name(str) The new name of the refactored method required Returns: Type Description No returns Source code in refactorings\\rename_method.py def __init__ ( self , java_file_path , common_token_stream , scope_class_name , target_method_name , new_name , reference = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods Args: java_file_path(str): Address path to the test/source file scope_class_name(str): Name of the class in which the refactoring has to be done target_method_name(str): Name of the method in which the refactoring has to be done new_name(str): The new name of the refactored method Returns: No returns \"\"\" self . file_path = java_file_path self . token_stream = common_token_stream self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . class_name = scope_class_name self . method_name = target_method_name self . new_method_name = new_name self . in_class = False self . changed = False self . reference = reference","title":"Rename method"},{"location":"refactorings/rename_method/#rename-method","text":"","title":"Rename method"},{"location":"refactorings/rename_method/#refactorings.rename_method.RenameMethodListener--introduction","text":"When the name of a method does not explain what the method does (method's functionality), it needs to be changed.","title":"Introduction"},{"location":"refactorings/rename_method/#refactorings.rename_method.RenameMethodListener--pre-and-post-conditions","text":"","title":"Pre and Post Conditions"},{"location":"refactorings/rename_method/#refactorings.rename_method.RenameMethodListener--pre-conditions","text":"User must enter the existing method's name, The source class's name for the refactoring, and the new method name in order to rename. Check if the method exist, then rename it.","title":"Pre Conditions:"},{"location":"refactorings/rename_method/#refactorings.rename_method.RenameMethodListener--post-conditions","text":"After refactoring, all the old method names in the project should be changed. See whether the method is defined in a superclass or subclass. If so, you must repeat all steps in these classes too. The next method is important for maintaining the functionality of the program during the refactoring process. Create a new method with a new name. Copy the code of the old method to it. Delete all the code in the old method and, instead of it, insert a call for the new method. Find all references to the old method and replace them with references to the new one. Delete the old method. If the old method is part of a public interface, don\u2019t perform this step. Instead, mark the old method as deprecated.","title":"Post Conditions:"},{"location":"refactorings/rename_method/#refactorings.rename_method.RenameMethodListener.__init__","text":"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods Parameters: Name Type Description Default java_file_path(str) Address path to the test/source file required scope_class_name(str) Name of the class in which the refactoring has to be done required target_method_name(str) Name of the method in which the refactoring has to be done required new_name(str) The new name of the refactored method required Returns: Type Description No returns Source code in refactorings\\rename_method.py def __init__ ( self , java_file_path , common_token_stream , scope_class_name , target_method_name , new_name , reference = None ): \"\"\"The Main listener which parses the file based on the provided information, using ANTLR parser generator and tokenization methods Args: java_file_path(str): Address path to the test/source file scope_class_name(str): Name of the class in which the refactoring has to be done target_method_name(str): Name of the method in which the refactoring has to be done new_name(str): The new name of the refactored method Returns: No returns \"\"\" self . file_path = java_file_path self . token_stream = common_token_stream self . token_stream_rewriter = TokenStreamRewriter ( common_token_stream ) self . class_name = scope_class_name self . method_name = target_method_name self . new_method_name = new_name self . in_class = False self . changed = False self . reference = reference","title":"__init__()"},{"location":"tutorials/antlr_advanced/","text":"ANTLR advanced tutorials To be announced.","title":"ANTLR advanced"},{"location":"tutorials/antlr_advanced/#antlr-advanced-tutorials","text":"To be announced.","title":"ANTLR advanced tutorials"},{"location":"tutorials/antlr_basics/","text":"ANTLR basic tutorials Introduction to ANTLR: Part I Antlr part1 introduction from Morteza Zakeri Introduction to ANTLR: Part II Antlr part2 getting_started_in_java from Morteza Zakeri Introduction to ANTLR: Part III Antlr part3 getting_started_in_c_sharp from Morteza Zakeri","title":"ANTLR basics"},{"location":"tutorials/antlr_basics/#antlr-basic-tutorials","text":"","title":"ANTLR basic tutorials"},{"location":"tutorials/antlr_basics/#introduction-to-antlr-part-i","text":"Antlr part1 introduction from Morteza Zakeri","title":"Introduction to ANTLR: Part I"},{"location":"tutorials/antlr_basics/#introduction-to-antlr-part-ii","text":"Antlr part2 getting_started_in_java from Morteza Zakeri","title":"Introduction to ANTLR: Part II"},{"location":"tutorials/antlr_basics/#introduction-to-antlr-part-iii","text":"Antlr part3 getting_started_in_c_sharp from Morteza Zakeri","title":"Introduction to ANTLR: Part III"},{"location":"tutorials/refactorings_basics/","text":"Refactoring basic tutorials To be announced.","title":"Refactoring basics"},{"location":"tutorials/refactorings_basics/#refactoring-basic-tutorials","text":"To be announced.","title":"Refactoring basic tutorials"}]}